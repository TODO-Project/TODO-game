using entrainementProjet1.Class.Main;
using m_test1_hugo.Class.Main;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Input;
using m_test1_hugo.Class.clothes;
using m_test1_hugo.Class.Main.outils_dev_jeu.pics;
using Microsoft.Xna.Framework.Audio;
using m_test1_hugo.Class.Main.Menus.pages;

namespace m_test1_hugo.Class.Bonuses
{
    class ClothBox:RandomBox
    {
        public override int chronoDuration { get; set; }
        public override bool isOpen { get; set; }
        public override bool pressButtonMsg { get; set; }
        public override bool FoundRandom { get; set; }
        public override bool Validated { get; set; }
        public override bool TimerStarted { get; set; }
        public override bool musicPlayed { get; set; }

        public ClothPic clothPic;

        public override SoundEffect sound { get; set; }
        public override DateTime chrono { get; set; }
        

        Player currentPlayer = GamePage.player;
        Cloth randomCloth;

        public ClothBox(Vector2 Position)
            :base(Position)
        {
            name = "clothBox";
            GamePage.BonusList.Add(this);
            currentRow = 1;
            chronoDuration = 30;
            LoadContent(Game1.Content);
        }

        /// <summary>
        /// methode qui genere un vetement aleatoire 
        /// </summary>
        public void RandomObject()
        {
            Random rnd = new Random();
            int RandInt = rnd.Next(Cloth.list.Count<Cloth>());
            randomCloth = Cloth.list[RandInt];
        }

        /// <summary>
        /// assignation du vetement au joueur
        /// </summary>
        /// <param name="player"></param>
        public override void interract(Player player)
        {
            if(randomCloth is Boots)
            {
                player.ClothesList[2] = randomCloth;
            }
            else if(randomCloth is Shirt)
            {
                player.ClothesList[0] = randomCloth;
            }
            else if (randomCloth is Pant)
            {
                player.ClothesList[1] = randomCloth;
                player.ClothesList[1].interract(player);
            }
            GamePage.BonusList.Remove(this);
            GamePage.PicList.Remove(clothPic);
        }

        public override void LoadContent(ContentManager content)
        {
            LoadContent(content, "Bonus/magicBox", 2, 1);
        }

        public override void Update(GameTime gametime)
        {
            if (SpriteCollision(currentPlayer.destinationRectangle))
            {
                this.pressButtonMsg = true;
                if (currentPlayer.Controls.Use && !isOpen)
                    isOpen = true;
            }
            else
            {
                this.pressButtonMsg = false;
            }
            if (isOpen)
            {
                if (!TimerStarted)
                {
                    RandomObject();
                    clothPic = new ClothPic(randomCloth, Position);
                    TimerStarted = true;
                    chrono = DateTime.Now;
                }
                else
                {
                    if(DateTime.Now > chrono.AddSeconds(chronoDuration))
                    {
                        ////console.writeLine(chronoDuration);
                        GamePage.BonusList.Remove(this);
                    }
                }

                currentRow = 0; // sprite ouvert
                pressButtonMsg = false;
                
                if (!currentPlayer.Controls.Use)
                    Validated = true;
                if (Validated && SpriteCollision(currentPlayer.destinationRectangle))
                {
                    pressButtonMsg = true;
                    if(currentPlayer.Controls.Use)
                    {
                        interract(currentPlayer);
                    }
                }
            }
        }
    }
}
﻿using m_test1_hugo.Class.Main;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Audio;
using m_test1_hugo.Class.Main.Menus.pages;

namespace m_test1_hugo.Class.Bonuses
{
    class Heal : Bonus
    {
        private int healing = 50;
        private SoundEffect sound;

        public Heal()
        {
            Position = new Vector2(100, 100);
            name = "heal";
            LoadContent(Game1.Content);
        }

        public override void interract(Player player)
        {
               sound.Play();
            
            GamePage.BonusList.Remove(this);
            if (player.Health + healing > player.MaxHealth)
            {
                player.Health = player.MaxHealth;
            }
            else
            {
                player.Health += healing;
            }
            
        }

        public override void LoadContent(ContentManager content)
        {
            LoadContent(content, "Bonus/Heal", 1, 1);
            sound = content.Load<SoundEffect>("audio/bonus/heal");
        }

        public override void Update(GameTime gametime)
         {
            for (var i = 0; i< GamePage.PlayerList.Count; i++)
            {
                Player currentPlayer = GamePage.PlayerList[i];
                if (this.SpriteCollision(currentPlayer.destinationRectangle))
                {
                    if(currentPlayer.Health < currentPlayer.MaxHealth)
                        interract(currentPlayer);
                }
            }
        }

    }
}
﻿using m_test1_hugo.Class.Main;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Input;
using m_test1_hugo.Class.Main.outils_dev_jeu.Affects;
using m_test1_hugo.Class.Main.outils_dev_jeu.ArmesVignette;
using Microsoft.Xna.Framework.Audio;
using m_test1_hugo.Class.Main.Menus.pages;

namespace m_test1_hugo.Class.Bonuses
{
    class MagicBox : RandomBox
    {
        #region attributs
        public override int chronoDuration { get;  set; }
        public override bool isOpen { get; set; }
        public override bool pressButtonMsg { get; set; }
        public override bool FoundRandom { get; set; }
        public override bool Validated { get; set; }
        public override bool TimerStarted { get; set; }
        public override bool musicPlayed { get; set; }

        public override SoundEffect sound { get; set; }
        public override DateTime chrono { get; set; }

        private int currentFake = 0;
        private int tempoDuration = 800; // milliseconds
        #endregion

        DateTime tempo;
        Weapon randomWeapon;
        WeaponPic weaponPic, fakewPic;
        Player currentPlayer = GamePage.player;
        public bool tempoStarted = false;

        /// <summary>
        /// assignation de l'arme aleatoire au joueur
        /// </summary>
        /// <param name="player"></param>
        public override void interract(Player player)
        {
            CharacterAffect.WeaponChange(player, randomWeapon);
            GamePage.PicList.Remove(weaponPic);
            GamePage.BonusList.Remove(this);
        }

        public override void LoadContent(ContentManager content)
        {
            LoadContent(content, "Bonus/magicBox", 2, 1);
            sound= content.Load<SoundEffect>("audio/bonus/magicbox");
        }

        public MagicBox(Vector2 Position)
            :base(Position)
        {
            LoadContent(Game1.Content);
            name = "magicBox";
            currentRow = 1;
            chronoDuration = 10;
        }

        /// <summary>
        /// genere une arme aleatoire
        /// </summary>
        public void RandomObject()
        {
            Random rnd = new Random();
            int RandInt = rnd.Next(Weapon.List.Count<Weapon>());
            randomWeapon = Weapon.List[RandInt];
            randomWeapon.Holder = currentPlayer;
            randomWeapon.CurrentAmmo = randomWeapon.MagazineSize;
            weaponPic = new WeaponPic(randomWeapon, Position);
            chrono = DateTime.Now;
            TimerStarted = true;
            FoundRandom = true;
        }

        public override void Update(GameTime gameTime)
        {
            if (this.SpriteCollision(currentPlayer.destinationRectangle))
            {
                this.pressButtonMsg = true;
                if (currentPlayer.Controls.Use && !isOpen)
                    isOpen = true;
            }
            else
            {
                this.pressButtonMsg = false;
            }
            if (isOpen)
            {
                if (!musicPlayed)
                {
                    sound.Play();
                    musicPlayed = true;
                }
                this.pressButtonMsg = false;
                currentRow = 0; // sprite ouvert
                if (!FoundRandom) // on va afficher les armes dans l'ordre 
                {

                    if (!tempoStarted)
                    {
                        tempo = DateTime.Now;
                        tempoStarted = true;
                        fakewPic = new WeaponPic(Weapon.List[currentFake], Position);
                    }
                    else
                    {
                        if (currentFake < Weapon.List.Length)
                        {
                            if (DateTime.Now > tempo.AddMilliseconds(tempoDuration))
                            {
                                tempoStarted = false;
                                GamePage.PicList.Remove(fakewPic);
                                currentFake++;
                                if (currentFake >= Weapon.List.Length) // si on a affiche toutes les armes, on en prend une vraie au hasard
                                {
                                    RandomObject();
                                }
                            }
                        }
                    }
                }
                else if (SpriteCollision(currentPlayer.destinationRectangle)) // si le joueur est sur la boite et qu'il peut prendre l'arme
                {
                    weaponPic.takeMsg = true;
                    if (currentPlayer.Controls.Use)
                    {
                        interract(currentPlayer);
                    }
                }

                if (TimerStarted)
                {
                    if (DateTime.Now > chrono.AddSeconds(chronoDuration))
                    {
                        GamePage.PicList.Remove(weaponPic);
                        GamePage.BonusList.Remove(this);
                    }
                    if (!SpriteCollision(currentPlayer.destinationRectangle))
                    {
                        weaponPic.takeMsg = false;
                    }
                }
            }
        }
    }
}
﻿using m_test1_hugo.Class.Main;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Audio;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace m_test1_hugo.Class.Bonuses
{
    public abstract class RandomBox :Bonus
    {

        public abstract bool isOpen { get; set; }
        public abstract bool pressButtonMsg { get; set; }
        public abstract bool FoundRandom { get; set; }
        public abstract bool Validated { get; set; }
        public abstract bool TimerStarted { get; set; }
        public abstract int chronoDuration { get; set; }
        public abstract bool musicPlayed { get; set; }
        public abstract DateTime chrono { get; set; }
        public abstract SoundEffect sound { get; set; }

        public RandomBox(Vector2 position)
        {
            Position = position;
            isOpen = false;
            pressButtonMsg = false;
            FoundRandom = false;
            Validated = false;
            TimerStarted = false;
            musicPlayed = false;
            LoadContent(Game1.Content);
        }
    }
}
﻿using m_test1_hugo.Class.Main;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;
using m_test1_hugo.Class.Main.Menus.pages;

namespace m_test1_hugo.Class.Bonuses
{
    class SpeedBuff : Bonus
    {
        public bool chronoStarted;

        DateTime chrono;
        int Duration = 3000;
        int moveSpeedBonus = 4;

        Player currentPlayer;

        public override void interract(Player player)
        {
            
        }

        public SpeedBuff()
        {
            LoadContent(Game1.Content);
            Position = new Vector2(700, 100);
            name = "speedBuff";
            currentRow = 0;
        }

        public override void LoadContent(ContentManager content)
        {
            LoadContent(content, "Bonus/speedBuff", 2, 1);
        }

        public override void Update(GameTime gametime)
        {
            if (!chronoStarted)
            {
                for (var i = 0; i < GamePage.PlayerList.Count; i++)
                {
                    currentPlayer = GamePage.PlayerList[i];
                    if (SpriteCollision(currentPlayer.destinationRectangle))
                    {
                        chrono = DateTime.Now;
                        chronoStarted = true;
                        currentPlayer.weapon.MovingMalus -= moveSpeedBonus;
                        currentRow = 1;
                    }
                }
            }
            if(chronoStarted && DateTime.Now > chrono.AddMilliseconds(Duration))
                GamePage.BonusList.Remove(this);

        }
    }
}
﻿
using m_test1_hugo.Class.Main;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;
using m_test1_hugo.Class.Main.Menus.pages;

namespace m_test1_hugo.Class.Bonuses
{
    public class Teleporter : Bonus
    {
        private bool isReady;
        private int coolDown = 5;
        private DateTime initChrono;
        const int Deplacement = 120;
        private int tempo = 50;
        private Teleporter link;
        public enum Side { Up, Right, Down, Left};

        private Side side;

        #region attr
        public bool IsReady
        {
            get
            {
                return isReady;
            }

            set
            {
                isReady = value;
            }
        }

        public int CoolDown
        {
            get
            {
                return coolDown;
            }

            set
            {
                coolDown = value;
            }
        }

        #endregion
        public Teleporter(Vector2 pos, Side side)
        {
            LoadContent(Game1.Content);
            name = "teleporter";
            this.side = side;
            this.Position = pos;
        }

        public override void interract(Player player)
        {
            if(IsReady)
            {
                IsReady = false;
                link.isReady = false;
                initChrono = DateTime.Now;
                link.initChrono = initChrono;
                player.Position = GetTpPlace(player);
            }
        }

        public void setLink(Teleporter teleporter)
        {
            teleporter.link = this;
            this.link = teleporter;
        }

        public Vector2 GetTpPlace(Player player)
        {
            Vector2 newPos = Vector2.Zero;
            switch (side)
            {
                case Side.Up:
                    newPos =  new Vector2(player.Position.X, player.Position.Y + Deplacement);
                    break;
                case Side.Down:
                    newPos = new Vector2(player.Position.X, player.Position.Y - Deplacement);
                    break;
                case Side.Left:
                    newPos = new Vector2(player.Position.X - Deplacement, player.Position.Y);
                    break;
                case Side.Right:
                    newPos = new Vector2(player.Position.X + Deplacement, player.Position.Y);
                    break;
            }
            return newPos;
        }

        public override void LoadContent(ContentManager content)
        {
            LoadContent(content, "Bonus/teleporter", 1, 2);
        }

        public override void Update(GameTime gametime)
        {
            currentColumn = isReady ? 0 : 1;

            if(!isReady)
            {
                if (DateTime.Now > initChrono.AddSeconds(CoolDown))
                {
                    link.isReady = true;
                    isReady = true;
                }
            }

            for (var i = 0; i < GamePage.PlayerList.Count; i++)
            {
                Player currentPlayer = GamePage.PlayerList[i];
                if (this.SpriteCollision(currentPlayer.destinationRectangle))
                {
                    interract(currentPlayer);
                }
            }

            Draw(Game1.spriteBatch);
        }
    }
}
﻿using m_test1_hugo.Class.Main;
using m_test1_hugo.Class.Main.interfaces;
using m_test1_hugo.Class.Weapons;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace m_test1_hugo.Class.Characters.Teams
{
    /*class Bot : Player
    {
    
        #region attributs

        #endregion

        #region constructeur
        /*public Bot(CharacterClass classe, Weapon weapon, Team team)
        {
            this.weapon = weapon;
            weapon.Holder = this;
            MoveSpeed = classe.MoveSpeed - weapon.MovingMalus;
            this.Health = classe.Health;
            CharacterList.Add(this);
            this.team = team;
            this.MaxHealth = Health;
        }
        #endregion
        */
}
﻿using Microsoft.Xna.Framework.Content;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace m_test1_hugo.Class.Main
{
    public abstract class CharacterClass
    {
        private int health;

        private int damageBonus;

        private int moveSpeed;

        #region
        public int Health
        {
            get
            {
                return health;
            }

            set
            {
                health = value;
            }
        }

        public int DamageBonus
        {
            get
            {
                return damageBonus;
            }

            set
            {
                damageBonus = value;
            }
        }

        public int MoveSpeed
        {
            get
            {
                return moveSpeed;
            }

            set
            {
                moveSpeed = value;
            }
        }
        #endregion
        //classe de personnage qu'on pourra choisir au début du jeu

    }
}﻿using System;
using m_test1_hugo.Class.Main;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;

namespace m_test1_hugo.Class.Characters
{
    class Sprinter : CharacterClass
    {
        //sprinter : peu de HP mais court vite

        public Sprinter()
        {
            MoveSpeed = 6;
            this.DamageBonus= 0;
            this.Health = 80;
        }
    }
}
﻿using m_test1_hugo.Class.Main;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace m_test1_hugo.Class.Characters.Classes
{
    class Tank : CharacterClass
    {
        public Tank()
        {
            this.DamageBonus = 0;
            this.Health = 125;
            this.MoveSpeed = 4;
        }
    }
}
﻿using m_test1_hugo.Class.Main;
using Microsoft.Xna.Framework;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace m_test1_hugo.Class.Characters.Teams
{
    public class Team
    {
        public List<Player> TeamPlayerList = new List<Player>();
        public static List<Team> TeamList = new List<Team>();

        public int _teamNumber;

        public Color _Color
        {
            get;
            set;
        }

        public string _name;

        public int _nbPlayers
        {
            get { return TeamPlayerList.Count(); }
        }

        private int teamKills;
        public int TeamKills
        {
            get
            {
                return teamKills;
            }

            set
            {
                teamKills = value;
            }
        }

        private bool gameWon
        {
            get
            {
                return TeamKills >= 10;
            }
        }

        public Team(int teamNumber, string name, Color color)
        {   
            this._Color = color;
            _teamNumber = teamNumber;
            _name = name;
            Team.TeamList.Add(this);
        }

        public void Update()
        {
            //if (gameWon)
                //Console.WriteLine("team " + _name + " wins !");
        }

    }
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using m_test1_hugo.Class.Weapons;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Input;
using m_test1_hugo.Class.Main.interfaces;
using m_test1_hugo.Class.Characters.Teams;
using entrainementProjet1.Class.Main;
using m_test1_hugo.Class.ControlLayouts;
using m_test1_hugo.Class.Main.Menus.healthBar;
using m_test1_hugo.Class.Main.Menus.pages;
using Microsoft.Xna.Framework.Audio;
using m_test1_hugo.Class.gamestates.tools;
using Lidgren.Network;

namespace m_test1_hugo.Class.Main
{
    public class Player : Character, Movable
    {
        #region attributs
        public HealthBar healthBar;
        public new ControlLayout Controls;
        public bool updateClothes = false;
        public Cloth[] ClothesList = new Cloth[3];
        public List<SoundEffect> killVoices = new List<SoundEffect> { };

        public float CA, CO;

        public int MoveSpeedBonus;
        private int moveSpeed; 

        public int damageBonus;

        private int kills;
        
        private int deaths;

        private int serie;

        private long id;

        private float remoteCursorX;
        private float remoteCursorY;
        #endregion

        #region properties
        public int Kills
        {
            get
            {
                return kills;
            }

            set
            {
                if (value >= 0)
                    kills = value;
                else
                    throw new Exception("kills ne peut etre negatif");
            }
        }
        public int Deaths
        {
            get
            {
                return deaths;
            }

            set
            {
                deaths = value;
            }
        }
        public int DamageBonus
        {
            get
            {
                if (ClothesList[0] != null)
                    return classe.DamageBonus + ClothesList[0].Bonus;
                else
                    return classe.DamageBonus;
            }
        }
        public override int MoveSpeed
        {
            get
            {
                moveSpeed = classe.MoveSpeed;
                if (ClothesList[2] != null)
                    moveSpeed += ClothesList[2].Bonus;

                if (weapon != null)
                    moveSpeed -= weapon.MovingMalus;

                return moveSpeed + MoveSpeedBonus;
            }

            set
            {
                moveSpeed = value;
            }
        }
        public int Serie
        {
            get
            {
                return serie;
            }

            set
            {
                serie = value;
            }
        }

        public int MaxHealth
        {
            get
            {
                if (ClothesList[1] != null)
                    return _maxHealth + ClothesList[1].Bonus;
                else
                    return _maxHealth;

            }
            set { _maxHealth = value; }
        }

        public long Id
        {
            get
            {
                return id;
            }

            set
            {
                id = value;
            }
        }

        public float RemoteCursorX
        {
            get
            {
                return remoteCursorX;
            }

            set
            {
                remoteCursorX = value;
            }
        }

        public float RemoteCursorY
        {
            get
            {
                return remoteCursorY;
            }

            set
            {
                remoteCursorY = value;
            }
        }


        #endregion

        #region constructeur
        public Player(CharacterClass classe, Weapon weapon, Team team, ControlLayout controlLayout, Vector2 Position)
        {
            #region sons
            for (int i = 1; i <= 8; i++)
            {
                killVoices.Add(Game1.Content.Load<SoundEffect>("audio/kills/" + i + "kill"));
            }

            #endregion
            this.weapon = weapon;
            if (weapon != null)
            {
                weapon.Holder = this;
            }
            this.classe = classe;
            this.Health = classe.Health;
            this.team = team;
            this.MaxHealth = Health;
            this.Controls = controlLayout;
            this.Position = Position;
            healthBar = new HealthBar(this);
            //Console.WriteLine(Position);
            Pseudo = "Jean-kevin";
            LoadContent(Game1.Content);
            team.TeamPlayerList.Add(this);
        }
        public Player(string pseudo, CharacterClass classe, Weapon weapon, Team team, ControlLayout controlLayout, Vector2 Position)
            :this(classe, weapon, team, controlLayout, Position)
        {
            if (pseudo != "" && pseudo != null)
                this.Pseudo = pseudo;
            else
                this.Pseudo = "Jean-kevin";
        }

        public Player(string pseudo, CharacterClass classe, Weapon weapon, Team team, ControlLayout controlLayout, Vector2 Position, long id)
            : this (pseudo, classe, weapon, team, controlLayout, Position)
        {
            Id = id;
        }
        #endregion

        #region deplacement + MouseRotation
        public void Control(GameTime gametime, int tileSize, int mapWidth, int mapHeight, CollisionLayer collisionLayer)
        {
            if (this == GamePage.player)
            {
                Update(gametime);
                if (Controls is Azerty || Controls is Qwerty)
                {
                    CA = -(this.Center.Y - Controls.CursorPosY);
                    CO = -(this.Center.X - Controls.CursorPosX);
                }

                MouseRotationAngle = (float)(Math.Atan(CA / CO));

                isMoving = false; // pas en mouvement

                #region mouvement du personnage 

                if (Controls.MoveLeft)
                {
                    moveLeft(tileSize, mapWidth, mapHeight, collisionLayer);
                }

                if (Controls.MoveDown)
                {
                    moveDown(tileSize, mapWidth, mapHeight, collisionLayer);
                }

                if (Controls.MoveUp)
                {
                    moveUp(tileSize, mapWidth, mapHeight, collisionLayer);
                }

                if (Controls.MoveRight)
                {
                    moveRight(tileSize, mapWidth, mapHeight, collisionLayer);
                }
                #endregion

                #region rotation du perso en fonction de la souris 

                //Console.WriteLine("CA :" + CA + " CO :" + CO );

                if (Controls.CursorPosX > Center.X && Controls.CursorPosY > Center.Y) // bas droit
                {
                    if (Controls.CursorPosX - Center.X > Controls.CursorPosY - Center.Y) // droit
                    {
                        currentRow = 2;
                        //Console.WriteLine("1.1");
                    }

                    else // bas
                    {
                        currentRow = 0;
                        //Console.WriteLine("1.2");
                    }
                }
                else if (Controls.CursorPosX < Center.X && Controls.CursorPosY < Center.Y)// haut gauche
                {
                    if (Center.X - Controls.CursorPosX < Center.Y - Controls.CursorPosY) // gauche
                    {
                        //Console.WriteLine("2.1");
                        currentRow = 1;
                    }

                    else // haut
                    {
                        currentRow = 3;
                        //Console.WriteLine("2.2");
                    }

                }
                else if (Controls.CursorPosX < Center.X && Controls.CursorPosY > Center.Y) // bas gauche
                {
                    //Console.WriteLine("ok3");
                    if (Math.Abs((Controls.CursorPosX - Center.X)) > Math.Abs((Controls.CursorPosY - Center.Y))) // gauche
                    {
                        currentRow = 3;
                        //Console.WriteLine("3.1");               
                    }

                    else // bas
                    {
                        currentRow = 0;
                        //Console.WriteLine("3.2");
                    }

                }
                else if (Controls.CursorPosX > Center.X && Controls.CursorPosY < Center.Y)// haut droit
                {
                    //Console.WriteLine("ok4");
                    if (Controls.CursorPosX - Center.X > (Center.Y - Controls.CursorPosY)) // droit
                    {
                        //Console.WriteLine("4.1");
                        currentRow = 2;
                    }

                    else // bas
                    {
                        currentRow = 1;
                        //Console.WriteLine("4.2");
                    }

                }
                
            }
            else
            {
                Update(gametime);
            }
            #endregion
        }
        public void Control(GameTime gametime)
        {
            if (Controls.Shoot)
            {
                shoot(MouseRotationAngle, WeaponPicker.CO > 0);
                if(weapon.tir != Weapon.methodeTir.auto)
                {
                    if(weapon is Shotgun)
                        weapon.RearmingTime = 1000;
                    else
                        weapon.RearmingTime = 400;
                }
                if (weapon.CurrentAmmo <=0)
                    weapon.CurrentAmmo = weapon.MagazineSize;
            }
            this.releasedGachette = true;
        }
        #endregion

        public void Update(GameTime gametime)
        {
            UpdateSprite(gametime); // update du sprite animé
           
            if (weapon != null)
            {
                if (Controls.Shoot)
                {
                    shoot(MouseRotationAngle);
                }

                if (Controls.Reload && !weapon.isFull)
                {
                    if (!weapon.NeedReloading)
                    {
                        InitReloading = DateTime.Now;
                        weapon.NeedReloading = true;
                    }
                }
            }

            UpdateCharacter(gametime);
            if (IsDead())
            {
                GamePage.PlayersToDraw.Remove(this);
                Deaths++;
                Serie = 0;
                GamePage.client.SendDeathMessage(Id);
            } 
        }
        
        public void Respawn(Vector2 spawn, List<Player> liste)
        {
            this.Position = spawn;
            this.Health = this.MaxHealth;
            liste.Add(this);
        }

        public void PlayVoiceKill(int serie)
        {
            if(serie < killVoices.Count)
            {
                killVoices[serie].Play();
            }
        }

        public override bool Equals(object obj)
        {
            if (obj == null || obj.GetType() != typeof(Player))
            {
                return false;
            }
            Player p = obj as Player;
            return Id == p.Id;
        }
    }
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;

namespace m_test1_hugo.Class.Main
{
    public abstract class AnimatedSprite : Sprite
    {
        #region encapsulation des attributs

        public int columns;
        public int rows;
        public int currentRow;
        public int currentColumn;
        public bool isMoving;
        public bool isMovingUp;

        public new int Height
        {
            get { return texture.Height / rows; }
        }

        public new int Width
        {
            get { return texture.Width / columns; }
        }

        public new Vector2 Center
        {
            get { return new Vector2(Position.X + Width / 2, Position.Y + Height / 2+ 12); }
        }

        private int currentFrame = 0;

        private int totalFrames { get { return rows * columns; } }

        
        private DateTime timeSinceLastFrame;
        // slow down frame animation 
        private int millisecondsPerFrame = 120;

        private Rectangle _sourceRectangle;
        public Rectangle sourceRectangle
        {
            get { return new Rectangle(Width * currentColumn, Height * currentRow, Width, Height); }
            set { _sourceRectangle = value; }
        }

        private Rectangle _destinationRectangle;
        public Rectangle destinationRectangle
        {
            get { return _destinationRectangle; }
            set { _destinationRectangle = value; }
        }
        #endregion

        public void UpdateSprite(GameTime gameTime)
        {
            destinationRectangle = new Rectangle(
                 (int)Position.X,
                 (int)Position.Y,
                 (int)Width,
                 (int)Height
             );

            if (isMoving)
            {
                
                if (DateTime.Now >= timeSinceLastFrame.AddMilliseconds(millisecondsPerFrame))
                {
                    timeSinceLastFrame = DateTime.Now;
                    currentColumn++;
                    if (currentColumn == columns)
                    {
                        currentColumn = 0;
                    }
                }
            }
        }

        public void LoadContent(ContentManager content, string textureName, int Rows, int Columns)
        {
            this.rows = Rows;
            this.columns = Columns;
            texture = Game1.Content.Load<Texture2D>(textureName);
        }

        public new void Draw(SpriteBatch spriteBatch)
        {
            spriteBatch.Draw(texture, destinationRectangle, sourceRectangle, Color.White);
        }
    }
}
﻿using m_test1_hugo.Class.Main.interfaces;
using m_test1_hugo.Class.Main.Menus.pages;
using Microsoft.Xna.Framework;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace m_test1_hugo.Class.Main
{
    public abstract class Bonus : AnimatedSprite, SpriteCollision
    {

        public Bonus()
        {
            GamePage.BonusList.Add(this);
        }
        /// <summary>
        /// methode qui va faire interragir le joueur avec le bonus
        /// </summary>
        /// <param name="player"></param>
        public abstract void interract(Player player);
        public string name;

        /// <summary>
        /// methode qui recupere la collision du bonus avec un joueur
        /// </summary>
        /// <param name="player"></param>
        /// <returns></returns>
        public bool SpriteCollision(Rectangle player)
        {
            return destinationRectangle.Intersects(player);
        }

        public abstract void Update(GameTime gametime);
       
    }
}
﻿using m_test1_hugo.Class.Characters.Teams;
using m_test1_hugo.Class.ControlLayouts;
using m_test1_hugo.Class.Main.interfaces;
using m_test1_hugo.Class.Tile_Engine;
using m_test1_hugo.Class.Weapons;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Audio;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace m_test1_hugo.Class.Main
{
    public abstract class Character : AnimatedSprite, TileCollision, SpriteCollision
    {

        #region mouseposition variables

        /* public abstract float CA // cote adjacent, relatif a la hauteur
         {
             get;
         }

         public abstract float CO // cote adjacent, relatif a la largeur
         {
             get;
         }*/

        public float MouseRotationAngle;

        #endregion

        //public abstract ControlLayout ControlLayout { get; set; }

        #region attributs
        private string pseudo;
        public string Pseudo
        {
            get
            {
                return pseudo;
            }
            set
            {
                if (value != null && value.Length < 17)
                    pseudo = value;
                else if (value == null)
                    pseudo = "";
                else
                    throw new NotSupportedException("le pseudo ne peut contenir plus de 15 caracteres !");
            }
        }

        protected bool releasedGachette;

        private Vector2 PseudoPosition
        {
            get
            {
                return new Vector2(Center.X, Center.Y + Height / 2);
            }
        }

        public bool IsDead() { return this.Health <= 0; }

        private SpriteFont font;
        public CharacterClass classe;

        public Weapon weapon;

        public Team team;

        public abstract int MoveSpeed
        {
            get;
            set;
        }

        private int health;
        public int Health
        {
            get { return health; }
            set { health = value; }
        }

        protected int _maxHealth;

        private float precision;

        #region chronos rechargement / rearmement
        // compteur qui se declenche quand on recharge
        private DateTime initReloading;
        public DateTime InitReloading
        {
            get { return initReloading; }
            set { initReloading = value; }
        }

        // compteur qui se declenche quand on rearme
        private DateTime initRearming;
        public DateTime InitRearming
        {
            get { return initRearming; }
            set { initRearming = value; }
        }

        public ControlLayout Controls { get; private set; }

        public float Precision
        {
            get
            {
                return precision;
            }

            set
            {
                precision = value;
            }
        }

        #endregion

        #endregion

        #region methodes deplacement
        public void moveLeft(int tileSize, int mapWidth, int mapHeight, CollisionLayer collisionLayer)
        {
            isMoving = true;
            if (TileCollision(this, tileSize, mapWidth, mapHeight, collisionLayer, 0))
                this.Position = new Vector2(this.Position.X - this.MoveSpeed, this.Position.Y);
        }

        public void moveRight(int tileSize, int mapWidth, int mapHeight, CollisionLayer collisionLayer)
        {
            isMoving = true;
            if (TileCollision(this, tileSize, mapWidth, mapHeight, collisionLayer, 1))
                this.Position = new Vector2(this.Position.X + this.MoveSpeed, this.Position.Y);
        }

        public void moveDown(int tileSize, int mapWidth, int mapHeight, CollisionLayer collisionLayer)
        {
            isMoving = true;
            if (TileCollision(this, tileSize, mapWidth, mapHeight, collisionLayer, 3))
                this.Position = new Vector2(this.Position.X, this.Position.Y + this.MoveSpeed);
        }

        public void moveUp(int tileSize, int mapWidth, int mapHeight, CollisionLayer collisionLayer)
        {
            isMoving = true;
            if (TileCollision(this, tileSize, mapWidth, mapHeight, collisionLayer, 2))
                this.Position = new Vector2(this.Position.X, this.Position.Y - this.MoveSpeed);
        }

        #endregion

        public bool TileCollision(Sprite objet1, int tileSize, int mapWidth, int mapHeight, CollisionLayer collisionLayer, int direction)
        {
            int tileX = (int)Math.Ceiling(((this.Center.X) / tileSize)) - 1;
            int tileY = (int)Math.Ceiling(((this.Center.Y) / tileSize)) - 1;

            switch (direction)
            {
                case 0:     // Gauche
                    if (tileX > 0)
                        tileX--;
                    break;
                case 1:     // Droite
                    if (tileX < mapWidth)
                        tileX++;
                    break;
                case 2:     // Haut
                    if (tileY > 0)
                        tileY--;
                    break;
                case 3:     // Bas
                    if (tileY < mapHeight)
                        tileY++;
                    break;
                default:
                    break;
            }
            return collisionLayer.GetTile(tileX, tileY);
        }

        public bool SpriteCollision(Rectangle objet1)
        {
            return false;
        }

        #region dessin
        public override void LoadContent(ContentManager content) // TODO
        {
            releasedGachette = true;
            if (team._teamNumber == 1) // TODO
            {
                LoadContent(content, "playerSP2", 4, 3);
            }
            else if (team._teamNumber == 2)
            {
                LoadContent(content, "moche", 4, 3);
            }

            if (weapon != null)
            {
                weapon.LoadContent(content);
            }
           
            font = content.Load<SpriteFont>("arial");
        }

        public void DrawCharacter(SpriteBatch spriteBatch)
        {
            if (Pseudo != null)
                spriteBatch.DrawString(font, Pseudo, PseudoPosition, team._Color, 0f,font.MeasureString(Pseudo)/2, 0.2f, SpriteEffects.None, 1f);
            if (this.currentRow != 1)
            {
                this.Draw(spriteBatch);
                if (weapon != null && weapon.Holder != null)
                    this.weapon.Draw(spriteBatch);
            }
            else
            {
                if (weapon != null && weapon.Holder != null)
                    this.weapon.Draw(spriteBatch);
                this.Draw(spriteBatch);
            }
        }

        #endregion

        internal bool CurrentlyRearming()
        {
            if (weapon.NeedRearming)
            {
                DateTime now = DateTime.Now;
                if (now > this.InitRearming.AddMilliseconds(weapon.RearmingTime))
                {
                    weapon.NeedRearming = false;
                    return true;
                }
            }
            return false;
        }

        public bool CanShoot()
        {
            if (weapon != null)
            {
                if (!weapon.NeedReloading)
                {
                    if (!this.weapon.isEmpty)
                    {
                        if (!this.CurrentlyRearming())
                        {
                            if (!this.weapon.NeedRearming)
                            {
                                return true;
                            }
                        }
                    }
                }
            }
            return false;
        }
        public void shoot(float AngleTir)
        {
            if (CanShoot())
            {
                if (((weapon.tir == Weapon.methodeTir.semiAuto || weapon.tir == Weapon.methodeTir.rafale) && releasedGachette) || weapon.tir == Weapon.methodeTir.auto)
                {
                    if (!releasedGachette)
                        Precision += 0.02f;

                    else
                        Precision = 0;

                    float spray = 0;
                    if (weapon.accuracy_malus > 0)
                    {
                        Random rnd = new Random();
                        spray = rnd.Next((int)(-10 * weapon.accuracy_malus), (int)(10 * weapon.accuracy_malus));//////
                    }
                    weapon.weaponSound.Play();
                    Random rnd1 = new Random();
                    float randomPrecision = Precision * (float)rnd1.Next(-3, 3) / 10;
                    new Bullet(this.weapon, AngleTir + spray / 10 + randomPrecision, true);
                    if (weapon is Shotgun)
                    {
                        new Bullet(this.weapon, AngleTir + 0.2f, true);
                        new Bullet(this.weapon, AngleTir - 0.2f, true);
                    }
                    else if (weapon is M16)
                    {
                        weapon.rafale = true;
                        weapon.rafaleCount = 0;
                        weapon.initTempo = DateTime.Now;
                    }
                    releasedGachette = false;
                    this.weapon.CurrentAmmo--;
                    this.weapon.NeedRearming = true;
                    InitRearming = DateTime.Now;
                }
            }
        }

        public void shoot(float AngleTir, bool sens)
        {
            if (CanShoot())
            {
                if (((weapon.tir == Weapon.methodeTir.semiAuto || weapon.tir == Weapon.methodeTir.rafale) && releasedGachette) || weapon.tir == Weapon.methodeTir.auto)
                {
                    if (!releasedGachette)
                        Precision += 0.02f;

                    else
                        Precision = 0;

                    float spray = 0;
                    if (weapon.accuracy_malus > 0)
                    {
                        Random rnd = new Random();
                        spray = rnd.Next((int)(-10 * weapon.accuracy_malus), (int)(10 * weapon.accuracy_malus));//////
                    }
                    weapon.weaponSound.Play();
                    Random rnd1 = new Random();
                    float randomPrecision = Precision * (float)rnd1.Next(-50, 50) / 50;
                    new Bullet(this.weapon, AngleTir + spray / 10 + randomPrecision, sens);
                    if (weapon is Shotgun)
                    {
                        new Bullet(this.weapon, AngleTir + 0.2f, sens, true);
                        new Bullet(this.weapon, AngleTir - 0.2f, sens, true);
                    }
                    else if (weapon is M16)
                    {
                        weapon.rafale = true;
                        weapon.rafaleCount = 0;
                        weapon.initTempo = DateTime.Now;
                    }
                    releasedGachette = false;
                    this.weapon.CurrentAmmo--;
                    this.weapon.NeedRearming = true;
                    InitRearming = DateTime.Now;
                }
            }
        }

        public void UpdateCharacter(GameTime gametime)
        {
            if (Mouse.GetState().LeftButton == ButtonState.Released)
                releasedGachette = true;
            if (weapon != null)
            {
                if (weapon.isEmpty)
                {
                    if (!weapon.NeedReloading)
                    {
                        InitReloading = DateTime.Now;
                        weapon.NeedReloading = true;
                    }
                }

                if (weapon.NeedReloading)
                {
                    // On récupère la date
                    DateTime now = DateTime.Now;

                    // On regarde si l'on a dépasé le temps de chargement
                    if (now > InitReloading.AddMilliseconds(weapon.ReloadingTime))
                    {
                        // On indique que l'on a fini de charger
                        weapon.NeedReloading = false;

                        //On recharge le chargeur 
                        weapon.CurrentAmmo = weapon.MagazineSize;
                    }
                }
            }
        }
    }
}﻿using Microsoft.Xna.Framework.Content;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace m_test1_hugo.Class.Main
{
    public abstract class CharacterClass
    {
        public int MoveSpeed;
        public int Health;

    }
}
﻿using m_test1_hugo.Class.clothes;
using m_test1_hugo.Class.Main;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace entrainementProjet1.Class.Main
{
    public abstract class Cloth : Sprite
    {
        public static Cloth[] list = new Cloth[]
        {
            new Shirt ("batMan", 50),
            new Shirt("superMan", 25),
            new Pant("superMan", 12),
            new Pant("batMan", 5),
            new Boots("batMan", 2),
            new Boots("superMan", 3)
        };

        //public abstract void Update(GameTime gameTime);
        public abstract void interract(Player player);

        public string clothName;

        public abstract int Bonus
        {
            get;
            set;
        }

        public Cloth(string name, int bonus)
        {
            this.clothName = name;
            this.Bonus = bonus;
        }

        public abstract void TakeOff(Player player);

    }
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework;
using System.Runtime.Remoting.Contexts;
using m_test1_hugo.Class.Main.interfaces;

namespace m_test1_hugo.Class.Main
{
    public abstract class Sprite : Drawable
    {
        public Texture2D texture;

        // idem rq je ne sais plus ou, stocke ta dernière position
        private Vector2 _position;

        //Mettre virtual pour pouvoir l'ovverider dans sniper
        // Et idem rq je ne sais plus pour le getter et setter
        virtual public Vector2 Position 
        {
            get
            {
                return this._position;
            } 
            
            set
            {
                this._position = value;
            }
        }

        public int Height
        {
            get { return texture.Height; }
        }

        public int Width
        {
            get { return texture.Width; }
        }

        public Vector2 Center
        {
            get { return new Vector2(Position.X + (Width / 2), Position.Y + (Height / 2)); }
        }

        private Rectangle bounds;
        public Rectangle Bounds
        {
            get { return new Rectangle((int)Position.X, (int)Position.Y, Width, Height); }
        }

        public Sprite()
        {
            Position = Vector2.Zero;
        }  

        public void Draw(SpriteBatch spriteBatch)
        {
             spriteBatch.Draw(texture, Position, Color.White);
        }

        public abstract void LoadContent(ContentManager content);
    }
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

using Microsoft.Xna.Framework;

namespace m_test1_hugo.Class.Main
{
    /// <summary>
    /// Décrit le moteur graphique du jeu
    /// </summary>
    class TileEngine
    {
        #region Fields

        /// <summary>
        /// La largeur des tiles, en pixels
        /// </summary>
        private static int tileWidth;

        /// <summary>
        /// La hauteur des tiles, en pixels
        /// </summary>
        private static int tileHeight;

        #endregion

        #region Properties

        /// <summary>
        /// Récupère et définit la largeur des tiles en pixels
        /// </summary>
        public static int TileWidth
        {
            get { return tileWidth; }
            set { tileWidth = value; }
        }

        /// <summary>
        /// Récupère et définit la largeur des tiles en pixels
        /// </summary>
        public static int TileHeight
        {
            get { return tileHeight; }
            set { tileHeight = value; }
        }

        #endregion

        #region Constructor

        /// <summary>
        /// Construit un moteur graphique selon la largeur et la hauteur des tiles
        /// </summary>
        /// <param name="tileWidth">La largeur des tiles en pixels</param>
        /// <param name="tileHeight">La hauteur des tiles en pixels</param>
        public TileEngine(int tileWidth, int tileHeight)
        {
            TileEngine.tileWidth = tileWidth;
            TileEngine.tileHeight = tileHeight;
        }

        #endregion

        #region Methods

        /// <summary>
        /// Récupère la position des tiles sur la map
        /// </summary>
        /// <param name="position">La position des tiles</param>
        /// <returns>Un point relatif au vector2</returns>
        public Point VectorToCell(Vector2 position)
        {
            return new Point((int)position.X / tileWidth, (int)position.Y / tileHeight);
        }

        #endregion
    }
}
﻿using entrainementProjet1.Class.Main;
using m_test1_hugo.Class.ControlLayouts;
using Microsoft.Xna.Framework;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace m_test1_hugo.Class.Main.outils_dev_jeu.Affects
{
    public static class CharacterAffect
    {
        public static void WeaponChange(Player player, Weapon weapon)
        {
            player.weapon = weapon;
            weapon.Holder = player;
        }
        
        public static void increaseMoveSpeed(Player player, int bonus)
        {
            player.MoveSpeed += bonus;
        }

        public static void decreaseMoveSpeed(Player player, int bonus)
        {
            player.MoveSpeed -= bonus;
        }

        public static void increaseDamages(Player player, int bonus)
        {
            player.damageBonus += bonus;
        }
        public static void decreaseDamages(Player player, int bonus)
        {
            player.damageBonus -= bonus;
        }

        public static void increaseHealth(Player player, int bonus)
        {
            player.Health += bonus;
            player.MaxHealth += bonus;
        }
        public static void decreaseHealth(Player player, int bonus)
        {
            player.Health -= bonus;
            player.MaxHealth -= bonus;
        }


    }
}
﻿using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace m_test1_hugo.Class.Main.outils_dev_jeu.ArmesVignette
{
    class WeaponPic : Sprite
    {
        public static List<WeaponPic> WeaponPicList = new List<WeaponPic>(); 

        private string textureName;
        public bool takeWeaponMsg = false;
        

        public WeaponPic(Weapon weapon, Vector2 position)
        {
            this.Position = new Vector2(position.X, position.Y-30 );
            textureName = weapon.Name;
            WeaponPicList.Add(this);
        }

        public override void LoadContent(ContentManager content)
        {
            texture = content.Load<Texture2D>("weapons/"+textureName);
        }
    }
}
﻿using m_test1_hugo.Class.Main.Menus.pages;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Input;
using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace m_test1_hugo.Class.ControlLayouts
{
    class Azerty : ControlLayout
    {
        /*  public Dictionary<string, bool> _controls = new Dictionary<string, bool>();
          public override Dictionary<string, bool> Controls
          {
              get { return _controls; }
              set { _controls = new Dictionary<string, bool>(); }
          }

          public bool W
          {
              get { return Keyboard.GetState().IsKeyDown(Keys.W); }
          }

          public Azerty()
          {
              Controls.Add("forward", W );
              /*Controls.Add("forward", W);
              /*Controls.Add("left", Keys.C);
              Controls.Add("right", Keys.D);
              Controls.Add("use", Keys.E);
          }*/
        
        public override bool MoveDown
        {
            get { return Keyboard.GetState().IsKeyDown(Keys.S); }
        }

        public override bool MoveUp
        {
            get { return Keyboard.GetState().IsKeyDown(Keys.Z); }
        }

        public override bool MoveLeft
        {
            get { return Keyboard.GetState().IsKeyDown(Keys.Q); }
        }

        public override bool MoveRight
        {
            get { return Keyboard.GetState().IsKeyDown(Keys.D); }
        }

        public override bool Reload
        {
            get { return Keyboard.GetState().IsKeyDown(Keys.R); }
        }

        public override bool Use
        {
            get { return Keyboard.GetState().IsKeyDown(Keys.E); }
        }

        public override bool Shoot
        {
            get { return Mouse.GetState().LeftButton == ButtonState.Pressed; }
        }

        /*public override Vector2 CursorPosition
        {
            get { return Game1.ms.Position.ToVector2(); }
        }*/

        public override float CursorPosX
        {
            get { return GamePage.camera.Origin.X + GamePage.ms.Position.X; }
        }

        public override float CursorPosY
        {
            get { return GamePage.camera.Origin.Y + GamePage.ms.Position.Y; }
        }
    }
}
﻿using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Input;
using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace m_test1_hugo.Class.ControlLayouts
{
    public abstract class ControlLayout
    {
        /*public abstract Dictionary<string, bool> Controls
        {
            get; set;
        }*/

        //++ definir clavier / souris

        public abstract bool MoveDown
        {
            get;
        }
        public abstract bool MoveUp
        {
            get;
        }

        public abstract bool MoveLeft
        {
            get;
        }

        public abstract bool MoveRight
        {
            get;
        }

        public abstract bool Reload
        {
            get;
        }

        public abstract bool Use
        {
            get;
        }

        public abstract bool Shoot
        {
            get;
        }

/*        public abstract Vector2 CursorPosition
        {
            get;
        }*/

        public abstract float CursorPosX
        {
            get;
        }

        public abstract float CursorPosY
        {
            get;
        }

        public float MenuCursorPosX
        {
            get { return Game1.WindowWidth / 2 + Mouse.GetState().Position.X; }
        }

        public float MenuCursorPosY
        {
            get { return Game1.WindowHeight / 2 + Mouse.GetState().Position.Y; }
        }
    }
}
﻿using m_test1_hugo.Class.ControlLayouts;
using m_test1_hugo.Class.Main.Menus.pages;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Input;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace m_test1_hugo.Class.Main.outils_dev_jeu.ControlLayouts
{
    class GamePadController:ControlLayout
    {
        GamePadState gp
        {
            get { return GamePage.gp; }
        }

        public override bool MoveDown
        {
            get { return gp.IsButtonDown(Buttons.LeftThumbstickDown); }
        }

        public override bool MoveUp
        {
            get { return gp.IsButtonDown(Buttons.LeftThumbstickUp); }
        }

        public override bool MoveLeft
        {
            get { return gp.IsButtonDown(Buttons.LeftThumbstickLeft); }
        }

        public override bool MoveRight
        {
            get { return gp.IsButtonDown(Buttons.LeftThumbstickRight); }
        }

        public override bool Reload
        {
            get { return gp.IsButtonDown(Buttons.X); }
        }

        public override bool Use
        {
            get { return gp.IsButtonDown(Buttons.A); }
        }

        public override bool Shoot
        {
            get { return gp.IsButtonDown(Buttons.RightShoulder); }
        }

        /**public override Vector2 CursorPosition
        {
            get { return Game1.gp.ThumbSticks.Right; }
        }*/

        public override float CursorPosX
        {
            get { return GamePage.gp.ThumbSticks.Right.X; }
        }

        public override float CursorPosY
        {
            get { return GamePage.gp.ThumbSticks.Right.Y; }
        }
    }
}
﻿using m_test1_hugo.Class.Main.Menus.pages;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Input;
using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace m_test1_hugo.Class.ControlLayouts
{
    class Qwerty : ControlLayout
    {
        /*  public Dictionary<string, bool> _controls = new Dictionary<string, bool>();
          public override Dictionary<string, bool> Controls
          {
              get { return _controls; }
              set { _controls = new Dictionary<string, bool>(); }
          }

          public bool W
          {
              get { return Keyboard.GetState().IsKeyDown(Keys.W); }
          }

          public Azerty()
          {
              Controls.Add("forward", W );
              /*Controls.Add("forward", W);
              /*Controls.Add("left", Keys.C);
              Controls.Add("right", Keys.D);
              Controls.Add("use", Keys.E);
          }*/

        public override bool MoveDown
        {
            get { return Keyboard.GetState().IsKeyDown(Keys.S); }
        }

        public override bool MoveUp
        {
            get { return Keyboard.GetState().IsKeyDown(Keys.W); }
        }

        public override bool MoveLeft
        {
            get { return Keyboard.GetState().IsKeyDown(Keys.A); }
        }

        public override bool MoveRight
        {
            get { return Keyboard.GetState().IsKeyDown(Keys.D); }
        }

        public override bool Reload
        {
            get { return Keyboard.GetState().IsKeyDown(Keys.R); }
        }

        public override bool Use
        {
            get { return Keyboard.GetState().IsKeyDown(Keys.E); }
        }

        public override bool Shoot
        {
            get { return Mouse.GetState().LeftButton == ButtonState.Pressed; }
        }

        /*public override Vector2 CursorPosition
        {
            get { return Game1.ms.Position.ToVector2(); }
        }*/

        public override float CursorPosX
        {
            get { return GamePage.camera.Origin.X + GamePage.ms.Position.X; }
        }

        public override float CursorPosY
        {
            get { return GamePage.camera.Origin.Y + GamePage.ms.Position.Y; }
        }

    }
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace m_test1_hugo.Class.Main.outils_dev_jeu
{
    // From http://stackoverflow.com/questions/20676185/xna-monogame-getting-the-frames-per-second
    public class FrameCounter
    {
        public FrameCounter() { }

        public long TotalFrames
        {
            get;
            private set;
        }

        public float TotalSeconds
        {
            get;
            private set;
        }

        public float AverageFPS
        {
            get;
            private set;
        }

        public float CurrentFPS
        {
            get;
            private set;
        }

        public const int MAX_SAMPLES = 100;

        private Queue<float> sampleBuffer = new Queue<float>();

        public bool Update(float deltaTime)
        {
            CurrentFPS = 1.0f / deltaTime;
            sampleBuffer.Enqueue(CurrentFPS);

            if (sampleBuffer.Count > MAX_SAMPLES)
            {
                sampleBuffer.Dequeue();
                AverageFPS = sampleBuffer.Average(i => i);
            }
            else
            {
                AverageFPS = CurrentFPS;
            }

            TotalFrames++;
            TotalSeconds += deltaTime;
            return true;
        }
    }
}
﻿using Microsoft.Xna.Framework;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.Xna.Framework.Graphics;
using m_test1_hugo.Class.Tile_Engine;

namespace m_test1_hugo.Class.Main.InputSouris
{
    public static class MouseLib
    {
        public static float posY // cote Oppose
        {
            get { return Camera.position.Y + Game1.ms.Y; }
        }

        public static float posX // cote Adjacent
        {
            get { return Camera.position.X + Game1.ms.X; }
        }
    }
}
  ﻿using m_test1_hugo.Class.Tile_Engine;
using Microsoft.Xna.Framework;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace m_test1_hugo.Class.Main.outils_dev_jeu
{
    public static class Spawn
    {
        public static Vector2 RandomVector(int mapWidth, int mapHeight)
        {
            Random rnd = new Random();
            int x = rnd.Next(mapWidth);
            int y = rnd.Next(mapHeight);
            return new Vector2(x, y);
        }

        public static Vector2 RandomVector(TileMap map)
        {
            Random rnd = new Random();
            int x = rnd.Next(map.MapLayers[0].Width * map.Tilesize);
            int y = rnd.Next(map.MapLayers[0].Height * map.Tilesize);

            while (map.PCollisionLayer.GetTile((x / map.Tilesize), (y / map.Tilesize)) == false)
            {
                x = rnd.Next(map.MapLayers[0].Width);
                y = rnd.Next(map.MapLayers[0].Height);
            }

            //Console.WriteLine(x + "   " + y);

            return new Vector2(x, y);
        }
    }
}
﻿using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Input;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace m_test1_hugo.Class.Main.interfaces
{
    interface Clickable
    {
        bool leftClick();
        bool rightClick();
    }
}
﻿using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace m_test1_hugo.Class.Main.interfaces
{
    interface Drawable
    {
        void LoadContent(ContentManager content);
        void Draw(SpriteBatch spriteBatch);
    }
}
﻿using Microsoft.Xna.Framework;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace m_test1_hugo.Class.Main.interfaces
{
    interface Movable
    {
        void Update(GameTime gametime);
    }
}
﻿using Microsoft.Xna.Framework;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace m_test1_hugo.Class.Main.interfaces
{
    interface SpriteCollision
    {
        bool SpriteCollision(Rectangle objet1 ); // objet 2 devra etre un rectangle pour utiliser Bounds.Intersects
    }
}
﻿using m_test1_hugo.Class.Tile_Engine;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace m_test1_hugo.Class.Main.interfaces
{
    interface TileCollision
    {
        bool TileCollision(Sprite objet1, int tileSize, int mapWidth, int mapHeight, CollisionLayer collisionLayer, int direction);

        
    }
}
﻿using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace m_test1_hugo.Class.Main.outils_dev_jeu.pics
{
    public abstract class Pics:Sprite
    {
        public abstract string textureName
        {
            get;
            set;
        }
        
        public abstract bool takeMsg
        {
            get;
            set;
        }

        public Pics(Vector2 position)
        {
            this.Position = new Vector2(position.X, position.Y - 30);
        }
    }
}
﻿using m_test1_hugo.Class.Main.Menus.pages;
using m_test1_hugo.Class.Main.outils_dev_jeu.pics;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace m_test1_hugo.Class.Main.outils_dev_jeu.ArmesVignette
{
    class WeaponPic : Pics
    {


        private Weapon weapon;

        public override bool takeMsg
        {
            get;
            set;
        }

        public override string textureName
        {
            get
            {
                return "";
            }

            set
            {
                textureName = "";
            }
        }

        public WeaponPic(Weapon weapon, Vector2 position)
            :base(position)
        {
            this.weapon = weapon;
            GamePage.PicList.Add(this);
            LoadContent(Game1.Content);
        }

        public override void LoadContent(ContentManager content)
        {
            if(weapon != null)
                texture = content.Load<Texture2D>("weapons/"+weapon.Name);
        }
    }
}
﻿using entrainementProjet1.Class.Main;
using m_test1_hugo.Class.clothes;
using m_test1_hugo.Class.Main.Menus.pages;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace m_test1_hugo.Class.Main.outils_dev_jeu.pics
{
    class ClothPic:Pics
    {
        public Cloth _cloth;

        public override string textureName
        {
            get;
            set;
        }

        public override bool takeMsg
        {
            get;
            set;
        }

        public override Vector2 Position { get; set; }

        public ClothPic(Cloth cloth, Vector2 position)
            :base(position)
        {
            _cloth = cloth;
            GamePage.PicList.Add(this);
            //Console.WriteLine(Position);
            LoadContent(Game1.Content);
        }

        public override void LoadContent(ContentManager content)
        {
            if (_cloth is Pant)
                texture = content.Load<Texture2D>("clothes/pants/" + _cloth.clothName );
            else if(_cloth is Boots)
                texture = content.Load<Texture2D>("clothes/boots/" + _cloth.clothName);
            else if(_cloth is Shirt)
                texture = content.Load<Texture2D>("clothes/shirts/" + _cloth.clothName);
        }

        public new void Draw(SpriteBatch spriteBatch)
        {  
            spriteBatch.Draw(texture, Position, null, Color.White, 0f, Vector2.Zero, 0.5f, SpriteEffects.None, 1.0f);
        }
    }
}
﻿using m_test1_hugo.Class.Network.Messages.Types;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace m_test1_hugo.Class.Network.Abstract
{
    /// <summary>
    /// Classe abstraite qui décrit un message venant du client
    /// </summary>
    public abstract class GameMessage : NetworkMessage
    {
        #region Fields

        /// <summary>
        /// Le type du message
        /// </summary>
        private GameMessageTypes messageType;

        #endregion

        #region Properties

        /// <summary>
        /// Récupère et définit le type du message
        /// </summary>
        public GameMessageTypes MessageType
        {
            get
            {
                return messageType;
            }

            set
            {
                messageType = value;
            }
        }

        #endregion
    }
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Lidgren.Network;

namespace m_test1_hugo.Class.Network.Abstract
{
    /// <summary>
    /// Classe abstraite décrivant un message envoyé
    /// </summary>
    public abstract class NetworkMessage
    {
        #region Methods

        /// <summary>
        /// Décode un message entrant et modifie ses valeurs internes
        /// </summary>
        /// <param name="msg">Le message entrant</param>
        public abstract void DecodeMessage(NetIncomingMessage msg);

        /// <summary>
        /// Encode un message sortant avec ses propriétés internes
        /// </summary>
        /// <param name="msg">Le message sortant</param>
        public abstract void EncodeMessage(NetOutgoingMessage msg);

        #endregion
    }
}
﻿using m_test1_hugo.Class.Network.Messages.Types;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace m_test1_hugo.Class.Network.Abstract
{
    /// <summary>
    /// Classe abstraite qui décrit un message venant du serveur
    /// </summary>
    public abstract class ServerMessage : NetworkMessage
    {
        #region Fields

        /// <summary>
        /// Le type du message
        /// </summary>
        private ServerMessageTypes messageType;

        #endregion

        #region Properties

        /// <summary>
        /// Récupère et définit le type du message
        /// </summary>
        public ServerMessageTypes MessageType
        {
            get
            {
                return messageType;
            }

            set
            {
                messageType = value;
            }
        }

        #endregion
    }
}
﻿using m_test1_hugo.Class.Network.Abstract;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Lidgren.Network;

namespace m_test1_hugo.Class.Network.Messages
{
    /// <summary>
    /// Décrit un message de confirmation d'arrivée en jeu
    /// </summary>
    public class ConfirmArrival : ServerMessage
    {
        /// <summary>
        /// Crée un message de confirmation d'arrivée en jeu
        /// </summary>
        public ConfirmArrival()
        {
            MessageType = Types.ServerMessageTypes.ConfirmArrival;    
        }

        /// <summary>
        /// Décode un message de confirmation d'arrivée en jeu
        /// </summary>
        /// <param name="msg">Le message entrant</param>
        public override void DecodeMessage(NetIncomingMessage msg)
        {
            MessageType = (Types.ServerMessageTypes)msg.ReadByte();
        }

        /// <summary>
        /// Encode un message de confirmation d'arrivée en jeu
        /// </summary>
        /// <param name="msg">Le message sortant</param>
        public override void EncodeMessage(NetOutgoingMessage msg)
        {
            msg.Write((byte)MessageType);
        }
    }
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Lidgren.Network;
using m_test1_hugo.Class.Network.Messages.Types;
using m_test1_hugo.Class.Network.Abstract;

namespace m_test1_hugo.Class.Network.Messages
{
    /// <summary>
    /// Décrit le message de demande de graine
    /// </summary>
    public class GetMapSeed : GameMessage
    {
        /// <summary>
        /// Construit le message
        /// </summary>
        public GetMapSeed()
        {
            MessageType = GameMessageTypes.GetMapSeed;
        }

        /// <summary>
        /// Décode un message de demande de graine
        /// </summary>
        /// <param name="msg">Le message entrant</param>
        public override void DecodeMessage(NetIncomingMessage msg)
        {
            MessageType = (GameMessageTypes)msg.ReadByte();
        }

        /// <summary>
        /// Encode un message de demande de graine
        /// </summary>
        /// <param name="msg">Le message sortant</param>
        public override void EncodeMessage(NetOutgoingMessage msg)
        {
            msg.Write((byte)MessageType);
        }
    }
}
﻿using Lidgren.Network;
using m_test1_hugo.Class.Main;
using m_test1_hugo.Class.Network.Abstract;
using m_test1_hugo.Class.Network.Messages.Types;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace m_test1_hugo.Class.Network.Messages
{
    /// <summary>
    /// Décrit un message d'envoi de données joueurs client => serveur
    /// </summary>
    public class PlayerDataGame : GameMessage
    {
        /// <summary>
        /// Récupère et définit le type du message
        /// </summary>
        public GameMessageTypes GameMessageType
        {
            get; set;
        }

        /// <summary>
        /// La santé du joueur
        /// </summary>
        public int Health
        {
            get; set;
        }

        /// <summary>
        /// La santé maximale du joueur
        /// </summary>
        public int MaxHealth
        {
            get; set;
        }

        /// <summary>
        /// L'orientation du joueur
        /// </summary>
        public int Row
        {
            get; set;
        }

        /// <summary>
        /// L'animation du joueur
        /// </summary>
        public int Column
        {
            get; set;
        }

        /// <summary>
        /// Rotation du joueur
        /// </summary>
        public float MouseRotationAngle
        {
            get; set;
        }

        /// <summary>
        /// Côté opposé utilisé pour les calculs de rotation
        /// </summary>
        public float CO
        {
            get; set;
        }

        /// <summary>
        /// La vitesse de déplacement du joueur
        /// </summary>
        public int MoveSpeed
        {
            get; set;
        }

        /// <summary>
        /// La position X du joueur
        /// </summary>
        public float PosX
        {
            get; set;
        }

        /// <summary>
        /// La position Y du joueur
        /// </summary>
        public float PosY
        {
            get; set;
        }

        /// <summary>
        /// L'ID du joueur
        /// </summary>
        public long ID
        {
            get; set;
        }

        /// <summary>
        /// Le pseudo du joueur
        /// </summary>
        public string Pseudo
        {
            get; set;
        }

        /// <summary>
        /// L'arme du joueur
        /// </summary>
        public string Weapon
        {
            get; set;
        }

        /// <summary>
        /// Construit un message d'envoi de joueur en précisant un joueur
        /// </summary>
        /// <param name="p">Le joueur dont il faut extraire les données</param>
        public PlayerDataGame(Player p)
        {
            GameMessageType = GameMessageTypes.SendPlayerData;
            Health = p.Health;
            MaxHealth = p.MaxHealth;
            Row = p.currentRow;
            Column = p.currentColumn;
            MouseRotationAngle = p.MouseRotationAngle;
            CO = p.CO;
            MoveSpeed = p.MoveSpeed;
            PosX = p.Position.X;
            PosY = p.Position.Y;
            ID = p.Id;
            Pseudo = p.Pseudo;
            Weapon = p.weapon.Name;
        }

        /// <summary>
        /// Construit un message d'envoi de joueur vide
        /// </summary>
        public PlayerDataGame()
        {
            GameMessageType = GameMessageTypes.SendPlayerData;
        }

        /// <summary>
        /// Décode un message d'envoi du joueur
        /// </summary>
        /// <param name="msg">Le message entrant</param>
        public override void DecodeMessage(NetIncomingMessage msg)
        {
            //GameMessageType = (GameMessageTypes)msg.ReadByte();
            Health = msg.ReadInt32();
            MaxHealth = msg.ReadInt32();
            Row = msg.ReadInt32();
            Column = msg.ReadInt32();
            MouseRotationAngle = msg.ReadFloat();
            CO = msg.ReadFloat();
            MoveSpeed = msg.ReadInt32();
            PosX = msg.ReadFloat();
            PosY = msg.ReadFloat();
            ID = msg.ReadInt64();
            Pseudo = msg.ReadString();
            Weapon = msg.ReadString();
        }

        /// <summary>
        /// Encode un message d'envoi de joueur
        /// </summary>
        /// <param name="msg">Le message sortant</param>
        public override void EncodeMessage(NetOutgoingMessage msg)
        {
            msg.Write((byte)GameMessageTypes.SendPlayerData);
            msg.Write(Health);
            msg.Write(MaxHealth);
            msg.Write(Row);
            msg.Write(Column);
            msg.Write(MouseRotationAngle);
            msg.Write(CO);
            msg.Write(MoveSpeed);
            msg.Write(PosX);
            msg.Write(PosY);
            msg.Write(ID);
            msg.Write(Pseudo);
            msg.Write(Weapon);
        }

        /// <summary>
        /// Permet d'afficher un message d'envoi de joueur (DEBUG)
        /// </summary>
        /// <returns>Un string décrivant le joueur</returns>
        public override string ToString()
        {
            return "[PLAYER DATA" + ID + "]"
                + "\n\tHealth : " + Health + "/" + MaxHealth
                + "\n\tMoveSpeed : " + MoveSpeed
                + "\n\tPosition : "
                    + "\n\t\tX : " + PosX
                    + "\n\t\tY : " + PosY;
        }

    }
}
﻿using m_test1_hugo.Class.Network.Abstract;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Lidgren.Network;
using m_test1_hugo.Class.Main.Menus.pages;

namespace m_test1_hugo.Class.Network.Messages
{
    /// <summary>
    /// Décrit un message d'arrivée au serveur
    /// </summary>
    public class SendArrival : GameMessage
    {
        /// <summary>
        /// Récupère et définit le pseudo du joueur
        /// </summary>
        public string Pseudo
        {
            get; set;
        }

        /// <summary>
        /// Le numéro de la team
        /// </summary>
        public int TeamNumber
        {
            get; set;
        }

        /// <summary>
        /// Récupère et définit l'ID du joueur
        /// </summary>
        public long ID
        {
            get; set;
        }

        /// <summary>
        /// L'arme du joueur
        /// </summary>
        public string Weapon
        {
            get; set;
        }

        /// <summary>
        /// Construit un message d'arrivée au serveur
        /// </summary>
        public SendArrival()
        {
            MessageType = Types.GameMessageTypes.SendArrival;
            ID = GamePage.unique_ID;

        }

        /// <summary>
        /// Construit un message d'arrivée au serveur en précisant le pseudo du joueur
        /// </summary>
        /// <param name="pseudo">Le pseudo du joueur</param>
        public SendArrival(string pseudo, int teamNumber, string weapon) : this()
        {
            Pseudo = pseudo;
            TeamNumber = teamNumber;
            Weapon = weapon;
        }

        /// <summary>
        /// Décode un message d'arrivée du serveur depuis un message entrant
        /// </summary>
        /// <param name="msg">Un message entrant</param>
        public override void DecodeMessage(NetIncomingMessage msg)
        {
            //MessageType = (Types.GameMessageTypes)msg.ReadByte();
            Pseudo = msg.ReadString();
            ID = msg.ReadInt64();
            TeamNumber = msg.ReadInt32();
            Weapon = msg.ReadString();
        }

        /// <summary>
        /// Encode un message entrant avec les données d'un message d'arrivée au serveur
        /// </summary>
        /// <param name="msg">Un message sortant</param>
        public override void EncodeMessage(NetOutgoingMessage msg)
        {
            msg.Write((byte)MessageType);
            msg.Write(Pseudo);
            msg.Write(ID);
            msg.Write(TeamNumber);
            msg.Write(Weapon);
        }
    }
}
﻿using m_test1_hugo.Class.Network.Abstract;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Lidgren.Network;
using m_test1_hugo.Class.Network.Messages.Types;

namespace m_test1_hugo.Class.Network.Messages
{
    /// <summary>
    /// Décrit un message d'envoi de graine de génération vers le client.
    /// </summary>
    public class SendMapSeed : ServerMessage
    {
        /// <summary>
        /// Récupère et définit la graine de génération de la carte
        /// </summary>
        public int GameSeed
        {
            get; set;
        }

        /// <summary>
        /// Construit un message d'envoi de graine de génération selon la graine
        /// </summary>
        /// <param name="gameSeed">La graine de génération</param>
        public SendMapSeed(int gameSeed)
        {
            MessageType = ServerMessageTypes.SendMapSeed;
            GameSeed = gameSeed;
        }

        /// <summary>
        /// Décode un message d'envoi de graine aléatoire et remplit ses données internes
        /// </summary>
        /// <param name="msg">Le message entrant</param>
        public override void DecodeMessage(NetIncomingMessage msg)
        {
            MessageType = (ServerMessageTypes)msg.ReadByte();
            GameSeed = msg.ReadInt32();

        }

        /// <summary>
        /// Encode un message sortant avec les données relatives au message
        /// </summary>
        /// <param name="msg">Le message sortant</param>
        public override void EncodeMessage(NetOutgoingMessage msg)
        {
            msg.Write((byte)MessageType);
            msg.Write(GameSeed);
        }
    }
}
﻿using m_test1_hugo.Class.Network.Abstract;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Lidgren.Network;
using m_test1_hugo.Class.Network.Messages.Types;

namespace m_test1_hugo.Class.Network.Messages
{
    /// <summary>
    /// Décrit un message d'arrivée de nouveau joueur, notifiée quand un nouveau joueur entre en jeu
    /// </summary>
    class SendNewPlayerNotification : ServerMessage
    {
        /// <summary>
        /// Récupère et définit le pseudo du nouveau joueur
        /// </summary>
        public string Pseudo
        {
            get; set;
        }

        /// <summary>
        /// Récupère et définit l'ID unique du nouveau joueur
        /// </summary>
        public long PlayerID
        {
            get; set;
        }

        /// <summary>
        /// Numéro de la team du joueur
        /// </summary>
        public int TeamNumber
        {
            get; set;
        }

        /// <summary>
        /// L'arme du joueur
        /// </summary>
        public string Weapon
        {
            get; set;
        }

        /// <summary>
        /// Construit un message d'arrivée de nouveau joueur
        /// </summary>
        public SendNewPlayerNotification()
        {
            MessageType = ServerMessageTypes.SendNewPlayerNotification;
        }

        /// <summary>
        /// Construit un message d'arrivée de nouveau joueur en précisant le pseudo
        /// </summary>
        /// <param name="pseudo">Le pseudo du nouveau joueur</param>
        public SendNewPlayerNotification(string pseudo, long ID, int teamNumber, string weapon)
            : this()
        {
            Pseudo = pseudo;
            PlayerID = ID;
            TeamNumber = teamNumber;
            Weapon = weapon;
        }

        /// <summary>
        /// Décode un message entrant de venue de nouveau joueur
        /// </summary>
        /// <param name="msg">Un message entrant</param>
        public override void DecodeMessage(NetIncomingMessage msg)
        {
            //MessageType = (ServerMessageTypes)msg.ReadByte();
            PlayerID = msg.ReadInt64();
            Pseudo = msg.ReadString();
            TeamNumber = msg.ReadInt32();
            Weapon = msg.ReadString();
        }

        /// <summary>
        /// Encode un message sortant de venue de nouveau joueur
        /// </summary>
        /// <param name="msg">Un message sortant</param>
        public override void EncodeMessage(NetOutgoingMessage msg)
        {
            msg.Write((byte)MessageType);
            msg.Write(PlayerID);
            msg.Write(Pseudo);
            msg.Write(TeamNumber);
            msg.Write(Weapon);
        }
    }
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace m_test1_hugo.Class.Network.Messages.Types
{
    /// <summary>
    /// Énumère tous les types de messages clients
    /// </summary>
    public enum GameMessageTypes
    {
        GetMapSeed = 1,          // Message de demande de récupération de seed
        SendPlayerData = 2,      // Envoi des données du joueur
        SendArrival = 3,         // Message d'arrivée du joueur sur le serveur
        NewBulletGame = 4,       // Envoi d'un message de nouvelle balle
        SendPlayerRespawn = 5,   // Message de respawn du joueur
        SendDeath = 6,           // Message de mort du joueur
        SendDisconnection = 7    // Message de déconnexion du joueur
    }
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace m_test1_hugo.Class.Network.Messages.Types
{
    /// <summary>
    /// Énumère tous les types de messages serveur
    /// </summary>
    public enum ServerMessageTypes
    {
        SendMapSeed = 255,                  // Envoi de la seed de la map
        SendPlayerData = 254,               // Redistribution des données du joueur
        SendNewPlayerNotification = 253,    // Distribution du nouveau joueur
        ConfirmArrival = 252,               // Confirmation d'arrivée sur le serveur
        NewBulletServer = 251,              // Distribution d'une nouvelle balle aux joueurs
        PlayerRespawn = 250,                // Distribution du respawn d'un joueur
        Death = 249,                        // Distribution de la mort d'un joueur
        Disconnection = 248                 // Distribution de la déconnexion du joueur
    }
}
﻿using m_test1_hugo.Class.Network.Abstract;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Lidgren.Network;

namespace m_test1_hugo.Class.Network.Messages
{
    public class NewBulletGame : GameMessage
    {
        /// <summary>
        /// L'ID du joueur qui a tiré
        /// </summary>
        public long PlayerID
        {
            get; set;
        }

        /// <summary>
        /// L'angle de tir de l'arme
        /// </summary>
        public float AngleTir
        {
            get; set;
        }

        /// <summary>
        /// Crée un message de nouvelle balle vide
        /// </summary>
        public NewBulletGame()
        {
            MessageType = Types.GameMessageTypes.NewBulletGame;
        }

        /// <summary>
        /// Crée un message de nouvelle balle, en spécifiant l'ID du joueur et l'angle de tir
        /// </summary>
        /// <param name="ID">L'ID du joueur</param>
        /// <param name="angleTir">L'angle de tir</param>
        public NewBulletGame(long ID, float angleTir)
            : this()
        {
            PlayerID = ID;
            AngleTir = angleTir;
        }

        public override void DecodeMessage(NetIncomingMessage msg)
        {
            PlayerID = msg.ReadInt64();
            AngleTir = msg.ReadFloat();
        }

        public override void EncodeMessage(NetOutgoingMessage msg)
        {
            msg.Write((byte)MessageType);
            msg.Write(PlayerID);
            msg.Write(AngleTir);
        }
    }
}
﻿using m_test1_hugo.Class.Network.Abstract;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Lidgren.Network;

namespace m_test1_hugo.Class.Network.Messages.Types
{
    public class NewBulletServer : ServerMessage
    {
        /// <summary>
        /// L'ID du joueur
        /// </summary>
        public long PlayerID
        {
            get; set;
        }

        /// <summary>
        /// L'angle de tir de la balle
        /// </summary>
        public float AngleTir
        {
            get; set;
        }

        /// <summary>
        /// Crée un message de nouvelle balle
        /// </summary>
        public NewBulletServer()
        {
            MessageType = ServerMessageTypes.NewBulletServer;
        }

        public override void DecodeMessage(NetIncomingMessage msg)
        {
            MessageType = (ServerMessageTypes)msg.ReadByte();
            PlayerID = msg.ReadInt64();
            AngleTir = msg.ReadFloat();
        }

        public override void EncodeMessage(NetOutgoingMessage msg)
        {
            msg.Write((byte)MessageType);
            msg.Write(PlayerID);
            msg.Write(AngleTir);
        }

        /// <summary>
        /// Transfère les données d'un message client vers ce message
        /// </summary>
        /// <param name="msg">Le message du client</param>
        public void TransferData(NewBulletGame msg)
        {
            PlayerID = msg.PlayerID;
            AngleTir = msg.AngleTir;
        }
    }
}
﻿using Lidgren.Network;
using m_test1_hugo.Class.Network.Abstract;
using m_test1_hugo.Class.Network.Messages.Types;
using m_test1_hugo.Class.Network.Messages;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using m_test1_hugo.Class.Main;
using Microsoft.Xna.Framework;
using m_test1_hugo.Class.Main.outils_dev_jeu.Affects;

namespace m_test1_hugo.Class.Network.Messages
{
    /// <summary>
    /// Décrit un message d'envoi de données de joueur serveur => client
    /// </summary>
    public class PlayerDataServer : ServerMessage
    {
        /// <summary>
        /// Récupère et définit le type du message
        /// </summary>
        public ServerMessageTypes ServerMessageType
        {
            get; set;
        }


        /// <summary>
        /// La santé du joueur
        /// </summary>
        public int Health
        {
            get; set;
        }

        /// <summary>
        /// La santé maximale du joueur
        /// </summary>
        public int MaxHealth
        {
            get; set;
        }

        /// <summary>
        /// L'orientation du joueur
        /// </summary>
        public int Row
        {
            get; set;
        }

        /// <summary>
        /// L'animation du joueur
        /// </summary>
        public int Column
        {
            get; set;
        }

        /// <summary>
        /// La rotation du joueur
        /// </summary>
        public float MouseRotationAngle
        {
            get; set;
        }

        /// <summary>
        /// Le côté opposé utilisé pour les calculs de rotation
        /// </summary>
        public float CO
        {
            get; set;
        }

        /// <summary>
        /// La vitesse de déplacement du joueur
        /// </summary>
        public int MoveSpeed
        {
            get; set;
        }

        /// <summary>
        /// La position X du joueur
        /// </summary>
        public float PosX
        {
            get; set;
        }

        /// <summary>
        /// La position Y du joueur
        /// </summary>
        public float PosY
        {
            get; set;
        }

        /// <summary>
        /// L'ID du joueur
        /// </summary>
        public long ID
        {
            get; set;
        }

        /// <summary>
        /// Le pseudo du joueur
        /// </summary>
        public string Pseudo
        {
            get; set;
        }

        /// <summary>
        /// L'arme du joueur
        /// </summary>
        public string PlayerWeapon
        {
            get; set;
        }

        /// <summary>
        /// Construit un message d'envoi de joueur
        /// </summary>
        public PlayerDataServer()
        {
            ServerMessageType = ServerMessageTypes.SendPlayerData;
        }

        /// <summary>
        /// Décode un message entrant de données
        /// </summary>
        /// <param name="msg"></param>
        public override void DecodeMessage(NetIncomingMessage msg)
        {
            //ServerMessageType = (ServerMessageTypes)msg.ReadByte();
            Health = msg.ReadInt32();
            MaxHealth = msg.ReadInt32();
            Row = msg.ReadInt32();
            Column = msg.ReadInt32();
            MouseRotationAngle = msg.ReadFloat();
            CO = msg.ReadFloat();
            MoveSpeed = msg.ReadInt32();
            PosX = msg.ReadFloat();
            PosY = msg.ReadFloat();
            ID = msg.ReadInt64();
            Pseudo = msg.ReadString();
            PlayerWeapon = msg.ReadString();
        }

        public override void EncodeMessage(NetOutgoingMessage msg)
        {
            msg.Write((byte)ServerMessageTypes.SendPlayerData);
            msg.Write(Health);
            msg.Write(MaxHealth);
            msg.Write(Row);
            msg.Write(Column);
            msg.Write(MouseRotationAngle);
            msg.Write(CO);
            msg.Write(MoveSpeed);
            msg.Write(PosX);
            msg.Write(PosY);
            msg.Write(ID);
            msg.Write(Pseudo);
            msg.Write(PlayerWeapon);
        }

        public override string ToString()
        {
            return "[PLAYER DATA " + ID + "] " + Pseudo
                + "\n\tHealth : " + Health + "/" + MaxHealth
                + "\n\tMoveSpeed : " + MoveSpeed
                + "\n\tPosition : "
                    + "\n\t\tX : " + PosX
                    + "\n\t\tY : " + PosY;
        }

        /// <summary>
        /// Transfère les données d'un message entrant
        /// </summary>
        /// <param name="pdata">Le message client</param>
        public void TransferData(PlayerDataGame pdata)
        {
            Health = pdata.Health;
            MaxHealth = pdata.MaxHealth;
            Row = pdata.Row;
            Column = pdata.Column;
            MouseRotationAngle = pdata.MouseRotationAngle;
            CO = pdata.CO;
            MoveSpeed = pdata.MoveSpeed;
            PosX = pdata.PosX;
            PosY = pdata.PosY;
            ID = pdata.ID;
            Pseudo = pdata.Pseudo;
            PlayerWeapon = pdata.Weapon;
        }
        
        /// <summary>
        /// Transfère les données du message vers un joueur
        /// </summary>
        /// <param name="p">Le joueur concerné</param>
        public void TransferDataToPlayer(Player p)
        {
            p.Health = Health;
            p.MaxHealth = MaxHealth;
            p.currentRow = Row;
            p.currentColumn = Column;
            p.MouseRotationAngle = MouseRotationAngle;
            p.CO = CO;
            p.MoveSpeed = MoveSpeed;
            Vector2 pos = new Vector2(PosX, PosY);
            p.Position = pos;
            p.Pseudo = Pseudo;
            if (p.weapon.Name != PlayerWeapon && PlayerWeapon != null)
            {
                CharacterAffect.WeaponChange(p, Weapon.WeaponDictionnary[PlayerWeapon]);
            }
        }
    }
}
﻿using m_test1_hugo.Class.Network.Abstract;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Lidgren.Network;

namespace m_test1_hugo.Class.Network.Messages
{
    public class PlayerDeathGame : GameMessage
    {
        /// <summary>
        /// L'ID du joueur
        /// </summary>
        public long PlayerID
        {
            get; set;
        }

        /// <summary>
        /// Crée un message de mort vide
        /// </summary>
        public PlayerDeathGame()
        {
            MessageType = Types.GameMessageTypes.SendDeath;
        }

        /// <summary>
        /// Crée un message de mort selon l'ID du joueur
        /// </summary>
        /// <param name="ID">L'ID du joueur</param>
        public PlayerDeathGame(long ID)
            : this ()
        {
            PlayerID = ID;
        }

        public override void DecodeMessage(NetIncomingMessage msg)
        {
            PlayerID = msg.ReadInt64();
        }

        public override void EncodeMessage(NetOutgoingMessage msg)
        {
            msg.Write((byte)MessageType);
            msg.Write(PlayerID);
        }
    }
}
﻿using m_test1_hugo.Class.Network.Abstract;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Lidgren.Network;

namespace m_test1_hugo.Class.Network.Messages
{
    class PlayerDeathServer : ServerMessage
    {
        /// <summary>
        /// L'ID du joueur
        /// </summary>
        public long PlayerID
        {
            get; set;
        }

        /// <summary>
        /// Crée un message de mort vide
        /// </summary>
        public PlayerDeathServer()
        {
            MessageType = Types.ServerMessageTypes.Death;
        }

        public override void DecodeMessage(NetIncomingMessage msg)
        {
            PlayerID = msg.ReadInt64();
        }

        public override void EncodeMessage(NetOutgoingMessage msg)
        {
            msg.Write((byte)MessageType);
            msg.Write(PlayerID);
        }

        /// <summary>
        /// Transfère les données du message entrant
        /// </summary>
        /// <param name="m">Le message entrant</param>
        public void TransferData(PlayerDeathGame m)
        {
            PlayerID = m.PlayerID;
        }
    }
}
﻿using m_test1_hugo.Class.Network.Abstract;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Lidgren.Network;

namespace m_test1_hugo.Class.Network.Messages
{
    public class PlayerDisconnect : ServerMessage
    {
        /// <summary>
        /// L'ID du joueur
        /// </summary>
        public long ID
        {
            get; set;
        }

        /// <summary>
        /// Crée un message de déconnexion du joueur vide
        /// </summary>
        public PlayerDisconnect()
        {
            MessageType = Types.ServerMessageTypes.Disconnection;
        }

        /// <summary>
        /// Crée un message de déconnexion du joueur selon l'ID du joueur
        /// </summary>
        /// <param name="id"></param>
        public PlayerDisconnect(long id)
            : this()
        {
            ID = id;
        }

        public override void DecodeMessage(NetIncomingMessage msg)
        {
            ID = msg.ReadInt64();
        }

        public override void EncodeMessage(NetOutgoingMessage msg)
        {
            msg.Write((byte)MessageType);
            msg.Write(ID);
        }
    }
}
﻿using m_test1_hugo.Class.Network.Abstract;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Lidgren.Network;

namespace m_test1_hugo.Class.Network.Messages
{
    public class RespawnPlayerGame : GameMessage
    {
        /// <summary>
        /// L'ID du joueur à respawn
        /// </summary>
        public long ID
        {
            get; set;
        }

        /// <summary>
        /// Crée un message de respawn de joueur vide
        /// </summary>
        public RespawnPlayerGame()
        {
            MessageType = Types.GameMessageTypes.SendPlayerRespawn;
        }

        /// <summary>
        /// Crée un message de respawn de joueur selon l'ID du joueur
        /// </summary>
        /// <param name="id">L'ID du joueur</param>
        public RespawnPlayerGame(long id)
            : this ()
        {
            ID = id;
        }

        public override void DecodeMessage(NetIncomingMessage msg)
        {
            ID = msg.ReadInt64();
        }

        public override void EncodeMessage(NetOutgoingMessage msg)
        {
            msg.Write((byte)MessageType);
            msg.Write(ID);
        }
    }
}
﻿using m_test1_hugo.Class.Network.Abstract;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Lidgren.Network;

namespace m_test1_hugo.Class.Network.Messages
{
    public class RespawnPlayerServer : ServerMessage
    {
        /// <summary>
        /// L'ID du joueur
        /// </summary>
        public long ID
        {
            get; set;
        }

        /// <summary>
        /// Crée un message de respawn de joueur
        /// </summary>
        public RespawnPlayerServer()
        {
            MessageType = Types.ServerMessageTypes.PlayerRespawn;
        }

        public override void DecodeMessage(NetIncomingMessage msg)
        {
            ID = msg.ReadInt64();
        }

        public override void EncodeMessage(NetOutgoingMessage msg)
        {
            msg.Write((byte)MessageType);
            msg.Write(ID);
        }

        /// <summary>
        /// Transfère les données du message entrant
        /// </summary>
        /// <param name="m">Le message entrant</param>
        public void TransferData(RespawnPlayerGame m)
        {
            ID = m.ID;
        }
    }
}
﻿using m_test1_hugo.Class.Network.Abstract;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Lidgren.Network;

namespace m_test1_hugo.Class.Network.Messages
{
    public class SendDisconnection : GameMessage
    {
        /// <summary>
        /// L'ID du joueur
        /// </summary>
        public long ID
        {
            get; set;
        }

        /// <summary>
        /// Crée un message de déconnexion vide
        /// </summary>
        public SendDisconnection()
        {
            MessageType = Types.GameMessageTypes.SendDisconnection;
        }

        /// <summary>
        /// Crée un message de déconnexion selon l'ID
        /// </summary>
        /// <param name="id">L'ID du joueur</param>
        public SendDisconnection(long id)
            : this()
        {
            ID = id;
        }

        public override void DecodeMessage(NetIncomingMessage msg)
        {
            ID = msg.ReadInt64();
        }

        public override void EncodeMessage(NetOutgoingMessage msg)
        {
            msg.Write((byte)MessageType);
            msg.Write(ID);
        }
    }
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Lidgren.Network;
using m_test1_hugo.Class.Network.Messages.Types;
using m_test1_hugo.Class.Network.Messages;
using System.Threading;
using System.Net;
using System.Net.Sockets;
using m_test1_hugo.Class.Main.Menus.pages;
using m_test1_hugo.Class.Main;
using m_test1_hugo.Class.Characters;
using m_test1_hugo.Class.Weapons;
using Microsoft.Xna.Framework;
using m_test1_hugo.Class.ControlLayouts;
using m_test1_hugo.Class.Main.outils_dev_jeu.ControlLayouts;
using m_test1_hugo.Class.Characters.Teams;

namespace m_test1_hugo.Class.Network
{
    /// <summary>
    /// Décrit le client du jeu, qui gère l'envoi de données au serveur et
    /// la réception des réponses de celui-ci
    /// </summary>
    public class Client
    {
        #region Fields

        /// <summary>
        /// Le NetClient associé au client
        /// </summary>
        private NetClient gameClient;

        /// <summary>
        /// La configuration initiale du client
        /// </summary>
        private NetPeerConfiguration conf;

        /// <summary>
        /// L'IP de l'hôte
        /// </summary>
        private string hostIP;

        /// <summary>
        /// Le port associé au client
        /// </summary>
        private int port;

        /// <summary>
        /// Décrit si le client fonctionne
        /// </summary>
        private bool isRunning = false;

        /// <summary>
        /// Décrit si le client est connecté
        /// </summary>
        private bool isConnected = false;

        /// <summary>
        /// La graine de génération aléatoire donnée par le serveur à la connexion
        /// </summary>
        private int mapSeed;

        /// <summary>
        /// Le player data associé au client
        /// </summary>
        private PlayerDataGame pdata;

        /// <summary>
        /// Le player data reçu depuis le serveur
        /// </summary>
        private PlayerDataServer recievedPlayerData;

        /// <summary>
        /// Décrit si le client devrait s'arrêter de fonctionner
        /// </summary>
        private bool shouldStop = false;

        /// <summary>
        /// Le thread de fonctionnement du client
        /// </summary>
        private Thread clThread;

        /// <summary>
        /// La liste des pseudos des joueurs
        /// </summary>
        private List<string> playerList;

        #endregion

        #region Properties

        /// <summary>
        /// Récupère le NetClient associé au client
        /// </summary>
        public NetClient GameClient
        {
            get
            {
                return gameClient;
            }

            private set
            {
                gameClient = value;
            }
        }

        /// <summary>
        /// Récupère et définit l'IP hôte
        /// </summary>
        public string HostIP
        {
            get
            {
                return hostIP;
            }

            set
            {
                hostIP = value;
            }
        }

        /// <summary>
        /// Récupère et définit le port
        /// </summary>
        public int Port
        {
            get
            {
                return port;
            }

            set
            {
                port = value;
            }
        }

        /// <summary>
        /// Récupère et définit le booléen de fonctionnement
        /// </summary>
        public bool IsRunning
        {
            get
            {
                return isRunning;
            }

            set
            {
                isRunning = value;
            }
        }

        /// <summary>
        /// Récupère et définit le booléen de connexion
        /// </summary>
        public bool IsConnected
        {
            get
            {
                return isConnected;
            }

            set
            {
                isConnected = value;
            }
        }

        /// <summary>
        /// Récupère et définit la graine de génération de la carte
        /// </summary>
        public int MapSeed
        {
            get
            {
                return mapSeed;
            }

            set
            {
                mapSeed = value;
            }
        }

        /// <summary>
        /// Récupère et définit les données du joueur
        /// </summary>
        internal PlayerDataGame Pdata
        {
            get
            {
                return pdata;
            }

            set
            {
                pdata = value;
            }
        }

        /// <summary>
        /// Récupère et définit le thread du client
        /// </summary>
        public Thread ClThread
        {
            get
            {
                return clThread;
            }

            set
            {
                clThread = value;
            }
        }

        /// <summary>
        /// Récupère et définit le booléen d'arrêt du thread
        /// </summary>
        public bool ShouldStop
        {
            get
            {
                return shouldStop;
            }

            set
            {
                shouldStop = value;
            }
        }

        /// <summary>
        /// Récupère et définit les données de joueur reçues depuis le serveur
        /// </summary>
        public PlayerDataServer RecievedPlayerData
        {
            get
            {
                return recievedPlayerData;
            }

            set
            {
                recievedPlayerData = value;
            }
        }

        /// <summary>
        /// Récupère et définit la liste des pseudos des joueurs
        /// </summary>
        public List<string> PlayerList
        {
            get
            {
                return playerList;
            }

            set
            {
                playerList = value;
            }
        }

        #endregion

        #region Constructors

        /// <summary>
        /// Construit un client selon l'IP et le port du serveur cible
        /// </summary>
        /// <param name="hostip">L'adresse IP du serveur</param>
        /// <param name="port">Le port du serveur</param>
        public Client(string hostip, int port)
        {
            conf = new NetPeerConfiguration("TODO-game");
            GameClient = new NetClient(conf);
            HostIP = hostip;
            Port = port;
            IsConnected = false;
        }

        #endregion

        #region Methods

        /// <summary>
        /// Démarre le client, le connecte et met à jour les propriétés initiales
        /// </summary>
        public void Start()
        {
            MapSeed = 0;
            GameClient.Start();
            IsRunning = true;
            GameClient.Connect(HostIP, Port);
            //System.Diagnostics.Debug.WriteLine("Client connecté à " + HostIP + ":" + Port);
        }

        /// <summary>
        /// La procédure principale du client, appelée par le thread ClThread.
        /// Il attend un message du serveur et le traite appropriémment.
        /// 1ms d'arrêt.
        /// </summary>
        public void HandleMessage()
        {
            while (!ShouldStop)
            {
                if (GamePage.player != null)
                {
                    FetchPlayerData();
                    SendPlayerDataToServer();
                }

                NetIncomingMessage inc;

                while ((inc = GameClient.ReadMessage()) != null)
                {
                    switch (inc.MessageType)
                    {
                        case NetIncomingMessageType.Error:

                            break;
                        case NetIncomingMessageType.StatusChanged:
                            //System.Diagnostics.Debug.Write("[CLIENT STATUS] Status changed : " + inc.ReadString());
                            break;
                        case NetIncomingMessageType.UnconnectedData:
                            break;
                        case NetIncomingMessageType.ConnectionApproval:
                            break;
                        case NetIncomingMessageType.Data:
                            TreatServerMessage(inc);
                            break;
                        case NetIncomingMessageType.Receipt:
                            break;
                        case NetIncomingMessageType.DiscoveryRequest:
                            break;
                        case NetIncomingMessageType.DiscoveryResponse:
                            break;
                        case NetIncomingMessageType.VerboseDebugMessage:
                        case NetIncomingMessageType.DebugMessage:
                            //System.Diagnostics.Debug.WriteLine("[CLIENT DEBUG MESSAGE] " + inc.ReadString());
                            break;
                        case NetIncomingMessageType.WarningMessage:
                            //System.Diagnostics.Debug.WriteLine("[CLIENT WARNING] " + inc.ReadString());
                            break;
                        case NetIncomingMessageType.ErrorMessage:
                            //System.Diagnostics.Debug.WriteLine("[CLIENT ERROR] " + inc.ReadString());
                            break;
                        case NetIncomingMessageType.NatIntroductionSuccess:
                            break;
                        case NetIncomingMessageType.ConnectionLatencyUpdated:
                            break;
                        default:
                            break;
                    }
                }
                Thread.Sleep(1);
            }
            
        }

        /// <summary>
        /// Procédure appelée quand un message de type Data est reçu ;
        /// elle trie les messages selon leur type et les traite.
        /// </summary>
        /// <param name="inc">Le message entrant</param>
        public void TreatServerMessage(NetIncomingMessage inc)
        {
            ServerMessageTypes messageType = (ServerMessageTypes)inc.ReadByte();

            switch (messageType)
            {
                case ServerMessageTypes.SendMapSeed:
                    MapSeed = inc.ReadInt32();
                    break;
                case ServerMessageTypes.SendPlayerData:
                    RecievedPlayerData = new PlayerDataServer();
                    RecievedPlayerData.DecodeMessage(inc);
                    break;
                case ServerMessageTypes.SendNewPlayerNotification:
                    SendNewPlayerNotification nplayer = new SendNewPlayerNotification();
                    nplayer.DecodeMessage(inc);
                    AddNewPlayer(nplayer.PlayerID, nplayer.Pseudo, nplayer.TeamNumber, nplayer.Weapon);
                    break;
                case ServerMessageTypes.ConfirmArrival:
                    IsConnected = true;
                    break;
                case ServerMessageTypes.NewBulletServer:
                    AddNewBullet(inc.ReadInt64(), inc.ReadFloat());
                    break;
                case ServerMessageTypes.PlayerRespawn:
                    RespawnPlayer(inc.ReadInt64());
                    break;
                case ServerMessageTypes.Death:
                    KillPlayer(inc.ReadInt64());
                    break;
                case ServerMessageTypes.Disconnection:
                    PlayerDisconnect msg = new PlayerDisconnect();
                    msg.DecodeMessage(inc);
                    GamePage.PlayerList.RemoveAll(x => x.Id == msg.ID);
                    GamePage.PlayersToDraw.RemoveAll(x => x.Id == msg.ID);
                    foreach (Team team in Team.TeamList)
                    {
                        team.TeamPlayerList.RemoveAll(x => x.Id == msg.ID);
                    }
                    break;
                default:
                    break;
            }
        }

        /// <summary>
        /// Arrête le thread du client. Est appelé lorsque
        /// le jeu est arrêté ou sur le menu principal
        /// </summary>
        public void RequestStop()
        {
            ShouldStop = true;
        }

        /// <summary>
        /// Récupère l'adresse IP locale de la forme
        /// 10.103.X.X, qui est l'apparence des adresses
        /// IP dans le réseau de l'IUT. A changer pour fonctionner
        /// avec tous types de réseau.
        /// </summary>
        /// <returns>Le string contenant l'adresse IP</returns>
        public static string GetLocalIPAddress()
        {
            String strHostName = string.Empty;
            strHostName = Dns.GetHostName();
            IPHostEntry ipEntry = Dns.GetHostEntry(strHostName);
            IPAddress[] addr = ipEntry.AddressList;
            IPAddress ip = Array.Find<IPAddress>(addr, x => x.ToString().Contains("10.103"));
            return ip.ToString();
        }
        
        /// <summary>
        /// Récupère les données du joueur de la session en vue
        /// de son envoi à chaque tick du client vers le serveur
        /// pour le distribuer aux autres clients
        /// </summary>
        public void FetchPlayerData()
        {
            Pdata = new PlayerDataGame(GamePage.player);
        }

        /// <summary>
        /// Vérifie si le joueur passé en paramètre est déjà dans la partie
        /// </summary>
        /// <param name="id">L'ID du joueur</param>
        /// <returns>True si le joueur est nouveau ; false sinon</returns>
        public bool CheckIfNewPlayer(long id)
        {
            foreach (Player p in GamePage.PlayerList)
            {
                if (p.Id == id)
                    return false;
            }
            foreach (Player p in GamePage.PlayersToDraw)
            {
                if (p.Id == id)
                    return false;
            }
            return true;
        }

        /// <summary>
        /// Envoie les données du joueur au serveur
        /// </summary>
        public void SendPlayerDataToServer()
        {
            NetOutgoingMessage outmsg = GameClient.CreateMessage();
            Pdata.EncodeMessage(outmsg);
            GameClient.SendMessage(outmsg, NetDeliveryMethod.ReliableOrdered);
        }

        /// <summary>
        /// Procédure appelée quand un nouveau joueur est entré
        /// en jeu
        /// </summary>
        /// <param name="ID">La connection du joueur</param>
        /// <param name="pseudo">Le pseudo du joueur</param>
        public void AddNewPlayer(long ID, string pseudo, int teamNumber, string weapon)
        {
            if (GamePage.PlayerList.Find(x => x.Id == ID) == null && GamePage.PlayersToDraw.Find(x => x.Id == ID) == null)
            {
                GamePage.PlayerList.Add(new Player(pseudo, new Sprinter(), Weapon.WeaponDictionnary[weapon], Team.TeamList[teamNumber - 1], new GamePadController(), new Vector2(0, 0), ID));
                GamePage.PlayersToDraw.Add(GamePage.PlayerList.Find(x => x.Id == ID));
            }
        }

        /// <summary>
        /// Ajoute une nouvelle balle dans le jeu
        /// </summary>
        /// <param name="ID">L'ID du joueur ayant tiré</param>
        /// <param name="angleTir">L'angle de tir</param>
        public void AddNewBullet(long ID, float angleTir)
        {
            Player p = GamePage.PlayerList.Find(x => x.Id == ID);
            if (p != null)
            {
                new Bullet(p.weapon, angleTir, false);
            }
        }

        /// <summary>
        /// Envoie un message de nouvelle balle au serveur
        /// </summary>
        /// <param name="ID">L'ID du joueur qui a tiré</param>
        /// <param name="angleTir">L'angle de tir</param>
        public void SendNewBullet(long ID, float angleTir)
        {
            NetOutgoingMessage outmsg = GameClient.CreateMessage();
            NewBulletGame nb = new NewBulletGame(ID, angleTir);
            nb.EncodeMessage(outmsg);
            GameClient.SendMessage(outmsg, NetDeliveryMethod.ReliableOrdered);
        }

        /// <summary>
        /// Fait revivre le joueur concerné
        /// </summary>
        /// <param name="ID">L'ID du joueur</param>
        public void RespawnPlayer(long ID)
        {
            Player p = GamePage.PlayerList.Find(x => x.Id == ID);
            if (p != null)
            {
                p.Respawn(Vector2.Zero, GamePage.PlayersToDraw);
            }
        }

        /// <summary>
        /// Envoie une notification de respawn du joueur
        /// </summary>
        /// <param name="ID">L'ID du joueur</param>
        public void SendRespawn(long ID)
        {
            NetOutgoingMessage outmsg = GameClient.CreateMessage();
            RespawnPlayerGame msg = new RespawnPlayerGame(ID);
            msg.EncodeMessage(outmsg);
            GameClient.SendMessage(outmsg, NetDeliveryMethod.ReliableOrdered); 
        }

        /// <summary>
        /// Tue le joueur passé en paramètre
        /// </summary>
        /// <param name="ID">L'ID du joueur à tuer</param>
        public void KillPlayer(long ID)
        {
            Player p = GamePage.PlayersToDraw.Find(x => x.Id == ID);
            if (p != null)
            {
                p.Health = -1;
            }
        }

        /// <summary>
        /// Envoie une notification de la mort du joueur au serveur
        /// </summary>
        /// <param name="ID">L'ID du joueur</param>
        public void SendDeathMessage(long ID)
        {
            NetOutgoingMessage outmsg = GameClient.CreateMessage();
            PlayerDeathGame msg = new PlayerDeathGame(ID);
            msg.EncodeMessage(outmsg);
            GameClient.SendMessage(outmsg, NetDeliveryMethod.ReliableOrdered);
        }

        /// <summary>
        /// Envoie une notification de déconnexion au serveur
        /// </summary>
        /// <param name="ID">L'ID du joueur</param>
        public void SendDisconnectionMessage(long ID)
        {
            NetOutgoingMessage outmsg = GameClient.CreateMessage();
            SendDisconnection msg = new SendDisconnection(ID);
            msg.EncodeMessage(outmsg);
            GameClient.SendMessage(outmsg, NetDeliveryMethod.ReliableOrdered);
        }

        #endregion
    }
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Lidgren.Network;
using m_test1_hugo.Class.Network.Messages.Types;
using m_test1_hugo.Class.Network.Messages;
using System.Threading;

namespace m_test1_hugo.Class.Network
{
    /// <summary>
    /// Définit une signature du joueur, permettant de l'identifier au niveau du serveur
    /// </summary>
    public struct PlayerSignature
    {
        public NetConnection Connection;
        public string Pseudo;
        public int Team;
        public long ID;
        public string Weapon;

        public PlayerSignature(string pseudo, int team, long id, string weapon, NetConnection connection)
        {
            Pseudo = pseudo;
            Team = team;
            ID = id;
            Weapon = weapon;
            Connection = connection;
        }
    }

    /// <summary>
    /// Décrit le serveur du jeu, qui va distribuer
    /// équitablement les données à tous les clients
    /// connectés.
    /// </summary>
    public class Server
    {
        #region Fields

        /// <summary>
        /// Le NetServer interne au serveur
        /// </summary>
        private NetServer gameserver;

        /// <summary>
        /// La configuration initiale du serveur
        /// </summary>
        private NetPeerConfiguration conf = new NetPeerConfiguration("TODO-game");

        /// <summary>
        /// Décrit si le serveur a démarré
        /// </summary>
        private bool hasStarted = false;

        /// <summary>
        /// Décrit si le thread du serveur devrait s'arrêter
        /// </summary>
        private bool shouldStop = false;

        /// <summary>
        /// Le thread du serveur
        /// </summary>
        private Thread svThread;

        /// <summary>
        /// La graine de génération de la carte
        /// </summary>
        private int gameSeed;

        private List<PlayerSignature> playerList;

        #endregion

        #region Properties

        /// <summary>
        /// Récupère le NetServer interne au serveur
        /// </summary>
        public NetServer GameServer
        {
            get
            {
                return gameserver;
            }

            private set
            {
                gameserver = value;
            }
        }

        /// <summary>
        /// Récupère et définit le booléen de démarrage du serveur
        /// </summary>
        public bool HasStarted
        {
            get
            {
                return hasStarted;
            }

            set
            {
                hasStarted = value;
            }
        }

        /// <summary>
        /// Récupère et définit le thread de travail du serveur
        /// </summary>
        public Thread SvThread
        {
            get
            {
                return svThread;
            }

            set
            {
                svThread = value;
            }
        }

        /// <summary>
        /// Récupère et définit le booléen d'arrêt du thread
        /// </summary>
        public bool ShouldStop
        {
            get
            {
                return shouldStop;
            }

            set
            {
                shouldStop = value;
            }
        }

        /// <summary>
        /// Récupère et définit la graine de génération de la carte
        /// </summary>
        public int GameSeed
        {
            get
            {
                return gameSeed;
            }

            set
            {
                gameSeed = value;
            }
        }

        /// <summary>
        /// La liste des joueurs
        /// </summary>
        public List<PlayerSignature> PlayerList
        {
            get
            {
                return playerList;
            }

            set
            {
                playerList = value;
            }
        }

        #endregion

        #region Constructors

        /// <summary>
        /// Construit un serveur de jeu
        /// </summary>
        public Server()
        {
            GameSeed = GenerateSeed();
            PlayerList = new List<PlayerSignature>();
            conf.MaximumConnections = 16;
            conf.Port = 12345;
            conf.EnableMessageType(NetIncomingMessageType.ConnectionApproval);
            conf.EnableMessageType(NetIncomingMessageType.UnconnectedData);

            GameServer = new NetServer(conf);
        }

        #endregion

        #region Methods

        /// <summary>
        /// Procédure démarrant le serveur et initialisant les propriétés de démarrage
        /// </summary>
        public void Start()
        {
            GameServer.Start();
            HasStarted = true;
            //System.Diagnostics.Debug.WriteLine("[INFO] Server has been created !");
            
        }

        /// <summary>
        /// La procédure principale du serveur, utilisée par le thread SvThread.
        /// Elle attend les messages des clients et les traite selon le message
        /// porté. 1ms d'arrêt.
        /// </summary>
        public void HandleMessages()
        {
            while (!ShouldStop)
            {
                NetIncomingMessage inc;

                while ((inc = GameServer.ReadMessage()) != null)
                {
                    switch (inc.MessageType)
                    {
                        case NetIncomingMessageType.Error:

                            break;
                        case NetIncomingMessageType.StatusChanged:
                            //System.Diagnostics.Debug.Write("[STATUS] Status changed : ");
                            switch ((NetConnectionStatus)inc.ReadByte())
                            {
                                case NetConnectionStatus.None:
                                    break;
                                case NetConnectionStatus.InitiatedConnect:
                                    break;
                                case NetConnectionStatus.ReceivedInitiation:
                                    break;
                                case NetConnectionStatus.RespondedAwaitingApproval:
                                    break;
                                case NetConnectionStatus.RespondedConnect:
                                    break;
                                case NetConnectionStatus.Connected:
                                    //System.Diagnostics.Debug.WriteLine(inc.SenderConnection + "is connected.");
                                    
                                    break;
                                case NetConnectionStatus.Disconnecting:
                                    //System.Diagnostics.Debug.WriteLine(inc.SenderConnection + "is disconnecting...");
                                    break;
                                case NetConnectionStatus.Disconnected:
                                    //System.Diagnostics.Debug.WriteLine(inc.SenderConnection + " has disconnected from the server !");
                                    SendDisconnectionMessage(PlayerList.Find(x => x.Connection == inc.SenderConnection).ID, inc);                               
                                    break;
                                default:
                                    break;
                            }
                            break;
                        case NetIncomingMessageType.UnconnectedData:
                            break;
                        case NetIncomingMessageType.ConnectionApproval:
                            //System.Diagnostics.Debug.WriteLine("[CONNECTION APPROVAL] New connection from : " + inc.SenderConnection);
                            inc.SenderConnection.Approve();
                            //System.Diagnostics.Debug.WriteLine("[CONNECTION APPROVAL] " + inc.SenderConnection + " has been approved !");
                            break;
                        case NetIncomingMessageType.Data:
                            TreatGameMessages(inc);
                            break;
                        case NetIncomingMessageType.Receipt:
                            break;
                        case NetIncomingMessageType.DiscoveryRequest:
                            break;
                        case NetIncomingMessageType.DiscoveryResponse:
                            break;
                        case NetIncomingMessageType.VerboseDebugMessage:
                        case NetIncomingMessageType.DebugMessage:
                            //System.Diagnostics.Debug.WriteLine("[DEBUG MESSAGE] " + inc.ReadString());
                            break;
                        case NetIncomingMessageType.WarningMessage:
                            //System.Diagnostics.Debug.WriteLine("[WARNING] " + inc.ReadString());
                            break;
                        case NetIncomingMessageType.ErrorMessage:
                            //System.Diagnostics.Debug.WriteLine("[ERROR] " + inc.ReadString());
                            break;
                        case NetIncomingMessageType.NatIntroductionSuccess:
                            break;
                        case NetIncomingMessageType.ConnectionLatencyUpdated:
                            break;
                        default:
                            break;
                    }
                }
                Thread.Sleep(1 * PlayerList.Count);
            }
            
        }

        /// <summary>
        /// Procédure qui traite les messages de type Data venant des client
        /// </summary>
        /// <param name="inc">Le message entrant</param>
        public void TreatGameMessages(NetIncomingMessage inc)
        {
            GameMessageTypes messagetype = (GameMessageTypes)inc.ReadByte();
            NetOutgoingMessage outmsg = GameServer.CreateMessage();

            switch (messagetype)
            {
                case GameMessageTypes.GetMapSeed:
                    NetOutgoingMessage outmsg1 = GameServer.CreateMessage();
                    SendMapSeed sendmapseed = new SendMapSeed(GameSeed);
                    sendmapseed.EncodeMessage(outmsg1);
                    NetSendResult res =GameServer.SendMessage(outmsg1, inc.SenderConnection, NetDeliveryMethod.ReliableOrdered);

                    break;
                case GameMessageTypes.SendPlayerData:
                    PlayerDataGame playerdatagame = new PlayerDataGame();
                    playerdatagame.DecodeMessage(inc);
                    PlayerDataServer playerdataserver = new PlayerDataServer();
                    playerdataserver.TransferData(playerdatagame);     
                    foreach (NetConnection co in GameServer.Connections)
                    {
                        if (co != inc.SenderConnection)
                        {
                            NetOutgoingMessage outmsg2 = GameServer.CreateMessage();
                            playerdataserver.EncodeMessage(outmsg2);
                            GameServer.SendMessage(outmsg2, co, NetDeliveryMethod.ReliableOrdered);
                        }
                    }
                    break;
                case GameMessageTypes.SendArrival:
                    NetOutgoingMessage outmsg3 = GameServer.CreateMessage();
                    SendArrival msg = new SendArrival();
                    msg.DecodeMessage(inc);
                    if (PlayerList.Count > 0)
                    {
                        foreach (PlayerSignature ps in PlayerList)
                        {
                            SendPlayerListToNewPlayer(ps, inc);
                        }
                    }
                    AddNewPlayerToList(msg.Pseudo, msg.TeamNumber, msg.ID, msg.Weapon, inc.SenderConnection);
                    SendNewPlayerMessage(inc, msg.Pseudo, msg.ID, msg.TeamNumber, msg.Weapon);
                    outmsg3 = GameServer.CreateMessage();
                    ConfirmArrival nmsg = new ConfirmArrival();
                    nmsg.EncodeMessage(outmsg3);
                    GameServer.SendMessage(outmsg3, inc.SenderConnection, NetDeliveryMethod.ReliableOrdered);
                    break;

                case GameMessageTypes.NewBulletGame:
                    NewBulletGame nbmsg = new NewBulletGame();
                    nbmsg.DecodeMessage(inc);
                    NewBulletServer nbmsg2 = new NewBulletServer();
                    nbmsg2.TransferData(nbmsg);
                    foreach (NetConnection co in GameServer.Connections)
                    {
                        if (co != inc.SenderConnection)
                        {
                            NetOutgoingMessage outmsg4 = GameServer.CreateMessage();
                            nbmsg2.EncodeMessage(outmsg4);
                            GameServer.SendMessage(outmsg4, co, NetDeliveryMethod.ReliableOrdered);
                        }
                    }
                    break;
                case GameMessageTypes.SendPlayerRespawn:
                    RespawnPlayerGame prmsg = new RespawnPlayerGame();
                    prmsg.DecodeMessage(inc);
                    RespawnPlayerServer prmsg2 = new RespawnPlayerServer();
                    prmsg2.TransferData(prmsg);
                    foreach (NetConnection co in GameServer.Connections)
                    {
                        if (co != inc.SenderConnection)
                        {
                            NetOutgoingMessage outmsg5 = GameServer.CreateMessage();
                            prmsg2.EncodeMessage(outmsg5);
                            GameServer.SendMessage(outmsg5, co, NetDeliveryMethod.ReliableOrdered);
                        }
                    }
                    break;

                case GameMessageTypes.SendDeath:
                    PlayerDeathGame pdmsg = new PlayerDeathGame();
                    pdmsg.DecodeMessage(inc);
                    PlayerDeathServer pdmsg2 = new PlayerDeathServer();
                    pdmsg2.TransferData(pdmsg);
                    foreach (NetConnection co in GameServer.Connections)
                    {
                        if (co != inc.SenderConnection)
                        {
                            NetOutgoingMessage outmsg6 = GameServer.CreateMessage();
                            pdmsg2.EncodeMessage(outmsg6);
                            GameServer.SendMessage(outmsg6, co, NetDeliveryMethod.ReliableOrdered);
                        }
                    }
                    break;

                case GameMessageTypes.SendDisconnection:
                    SendDisconnectionMessage(inc.ReadInt64(), inc);
                    break;
                default:
                    break;
            }
        }

        /// <summary>
        /// Génère la graine de génération de la carte.
        /// Est appelé au démarrage du serveur et n'est plus
        /// jamais changé.
        /// </summary>
        /// <returns>La graine de génération de la carte</returns>
        public int GenerateSeed()
        {
            return Guid.NewGuid().GetHashCode();
        }

        /// <summary>
        /// Procédure arrêtant le thread du serveur. Est
        /// appelé lorsque le jeu hôte est arrêté.
        /// </summary>
        public void RequestStop()
        {
            ShouldStop = true;
        }

        /// <summary>
        /// Ajoute un nouveau joueur dans la liste du serveur
        /// </summary>
        /// <param name="pseudo">Le pseudo du joueur</param>
        /// <param name="team">L'équipe du joueur</param>
        /// <param name="ID">L'ID du joueur</param>
        /// <param name="weapon">L'arme du joueur</param>
        /// <param name="co">La connexion du joueur</param>
        private void AddNewPlayerToList(string pseudo, int team, long ID, string weapon, NetConnection co)
        {
            PlayerList.Add(new PlayerSignature(pseudo, team, ID, weapon, co));
        }

        /// <summary>
        /// Envoie un message de nouveau joueur à tous les autres joueurs
        /// </summary>
        /// <param name="inc">Le message entrant</param>
        /// <param name="pseudo">Le pseudo du joueur</param>
        /// <param name="ID">L'ID du joueur</param>
        /// <param name="teamNumber">Le numéro d'équipe du joueur</param>
        /// <param name="weapon">L'arme du joueur</param>
        public void SendNewPlayerMessage(NetIncomingMessage inc, string pseudo, long ID, int teamNumber, string weapon)
        {
            //System.Diagnostics.Debug.WriteLine("[SERVER] NEW PLAYER DETECTED");
            SendNewPlayerNotification msg = new SendNewPlayerNotification(pseudo, ID, teamNumber, weapon);
            foreach (NetConnection c in GameServer.Connections)
            {
                if (c != inc.SenderConnection)
                {
                    NetOutgoingMessage outmsg = GameServer.CreateMessage();
                    msg.EncodeMessage(outmsg);
                    GameServer.SendMessage(outmsg, c, NetDeliveryMethod.ReliableOrdered);
                }
            }
        }

        /// <summary>
        /// Envoie la liste des joueurs au nouveau joueur
        /// </summary>
        /// <param name="ps">La signature d'un joueur connecté</param>
        /// <param name="inc">Le message entrant</param>
        public void SendPlayerListToNewPlayer(PlayerSignature ps, NetIncomingMessage inc)
        {
            NetOutgoingMessage outmsg = GameServer.CreateMessage();
            SendNewPlayerNotification msg = new SendNewPlayerNotification(ps.Pseudo, ps.ID, ps.Team, ps.Weapon);
            msg.EncodeMessage(outmsg);
            GameServer.SendMessage(outmsg, inc.SenderConnection, NetDeliveryMethod.ReliableOrdered);
        }

        /// <summary>
        /// Envoie une notification de déconnexion aux autres joueurs
        /// </summary>
        /// <param name="Id">L'ID du joueur déconnecté</param>
        /// <param name="inc">Le message entrant</param>
        public void SendDisconnectionMessage(long Id, NetIncomingMessage inc)
        {
            
            foreach (NetConnection co in GameServer.Connections)
            {
                if (co != inc.SenderConnection)
                {
                    NetOutgoingMessage outmsg = GameServer.CreateMessage();
                    PlayerDisconnect msg = new PlayerDisconnect(Id);
                    msg.EncodeMessage(outmsg);
                    GameServer.SendMessage(outmsg, co, NetDeliveryMethod.ReliableOrdered);
                }
            }
            PlayerList.RemoveAll(x => x.Connection == inc.SenderConnection);
        }

        #endregion

    }
}
﻿using m_test1_hugo.Class.Main.Menus.pages;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace m_test1_hugo.Class.Tile_Engine
{
    /// <summary>
    /// Décrit la caméra du jeu, qui suit le joueur sur la carte
    /// </summary>
    public class Camera
    {
        #region Fields

        /// <summary>
        /// Le niveau de zoom de la caméra (non utilisé)
        /// </summary>
        private float zoom;

        /// <summary>
        /// Le viewport (objet de transition vers l'écran propre au framework)
        /// </summary>
        private readonly Viewport viewport;

        /// <summary>
        /// La position de la caméra exprimée en vecteur 2D
        /// </summary>
        public static Vector2 position;

        /// <summary>
        /// L'origine de la caméra (non utilisé)
        /// </summary>
        private Vector2 origin;

        #endregion

        #region Properties

        /// <summary>
        /// Récupère et définit le niveau de zoom de la caméra entre 0 et 8.
        /// </summary>
        public float Zoom
        {
            get { return zoom; }
            set
            {
                zoom = value;
                if (zoom > 8.0f)
                    zoom = 8.0f;
            }
        }

        /// <summary>
        /// Récupère et définit la position de la caméra
        /// </summary>
        public Vector2 Position
        {
            get { return position; }
            set { position = value; }
        }

        /// <summary>
        /// Récupère et définit l'origine de la caméra (non utilisé)
        /// </summary>
        public Vector2 Origin
        {
            get { return origin; }
            set { origin = value; }
        }

        #endregion

        #region Constructors

        /// <summary>
        /// Construit une caméra selon un viewport (celui de l'écran en général)
        /// </summary>
        /// <param name="viewport">Le viewport sur lequel la caméra se base</param>
        public Camera(Viewport viewport)
        {
            this.viewport = viewport;
            zoom = 1.0f;
            position = Vector2.Zero;
            origin = new Vector2(viewport.Width / 2f, viewport.Height / 2f);
        }

        /// <summary>
        /// Construit une caméra selon un viewport et une position initiale.
        /// </summary>
        /// <param name="viewport">Le viewport sur lequel la caméra se base</param>
        /// <param name="position">La position initiale de la caméra</param>

        public Camera(Viewport viewport, Vector2 position)
        {
            this.viewport = viewport;
            zoom = 1.0f;
            Camera.position = position;
            origin = new Vector2(GamePage.player.Center.X - viewport.Width / 2f, GamePage.player.Center.Y - viewport.Height / 2f);
        }

        #endregion

        #region Methods

        /// <summary>
        /// Calcule et renvoie la matrice de transformation qui sera appliquée au spritebatch
        /// et qui fera en sorte de suivre le joueur
        /// </summary>
        /// <returns>Une matrice de transformation de la caméra</returns>
        public Matrix GetViewMatrix()
        {
            origin = new Vector2(GamePage.player.Center.X - viewport.Width / 2f, GamePage.player.Center.Y - viewport.Height / 2f);
            return
                Matrix.CreateTranslation(new Vector3(-Position, 0.0f)) *
                Matrix.CreateTranslation(new Vector3(-origin, 0.0f)) *
                Matrix.CreateScale(Zoom, Zoom, 1); 
        }

        #endregion
    }
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace m_test1_hugo.Class
{
    /// <summary>
    /// Décrit une couche de collision entre les entités et la carte
    /// </summary>
    public class CollisionLayer
    {
        #region Fields

        /// <summary>
        /// La carte de collision, représentée par des booléens :
        ///     - True : Pas de collision
        ///     - False : Collision
        /// </summary>
        bool[,] map;

        #endregion

        #region Constructors

        /// <summary>
        /// Construit une couche de collision selon sa taille
        /// </summary>
        /// <param name="height">La hauteur de la couche de collision, en tiles</param>
        /// <param name="width">La largueur de la couche de collision, en tiles</param>
        public CollisionLayer(int height, int width)
        {
            map = new bool[height, width];

            for (int y = 0; y < height; y++)
            {
                for (int x = 0; x < width; x++)
                {
                    SetTile(x, y, true);
                }
            }
        }

        #endregion

        #region Methods

        /// <summary>
        /// Récupère la valeur de collision d'une tile de la couche de collision
        /// </summary>
        /// <param name="x">Coordonnée x de la tile</param>
        /// <param name="y">Coordonnée y de la tile</param>
        /// <returns>Une valeur CollisionType (true or false)</returns>
        public bool GetTile(int x, int y)
        {
            return map[y, x];
        }

        /// <summary>
        /// Met une tile de la couche de collision à une valeur
        /// </summary>
        /// <param name="x">Coordonnée x de la tile</param>
        /// <param name="y">Coordonnée y de la tile</param>
        /// <param name="value">Valeur de la collision (true ou false)</param>
        public void SetTile(int x, int y, bool value)
        {
            map[y, x] = value;
        }

        #endregion
    }
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace m_test1_hugo.Class.Tile_Engine
{
    /// <summary>
    /// Décrit une case dans la carte, utilisée pour construire la carte
    /// </summary>
    public class Tile
    {
        #region Fields

        /// <summary>
        /// Le numéro de la tile dans le tileset
        /// </summary>
        int tileIndex;

        /// <summary>
        /// Le numéro du tileset
        /// </summary>
        int tileset;

        #endregion

        #region Properties

        /// <summary>
        /// Récupère et définit le numéro de la tile dans le tileset
        /// </summary>
        public int TileIndex
        {
            get { return tileIndex; }
            set { tileIndex = value; }
        }

        /// <summary>
        /// Récupère et définit le numéro du tileset
        /// </summary>
        public int Tileset
        {
            get { return tileset; }
            set { tileset = value; }
        }

        #endregion

        #region Constructor

        /// <summary>
        /// Construit un tile selon son numéro de tile dans le tileset et le tileset utilisé
        /// </summary>
        /// <param name="tileIndex">Le numéro du tile dans le tileset</param>
        /// <param name="tileset">Le numéro du tileset</param>
        public Tile(int tileIndex, int tileset)
        {
            TileIndex = tileIndex;
            Tileset = tileset;
        }

        #endregion
    }
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;

namespace m_test1_hugo.Class.Tile_Engine
{
    /// <summary>
    /// Définit un tileset, c'est à dire un liste de tous les tiles
    /// utilisables sur la carte de jeu, récupérée depuis une image.
    /// </summary>
    public class Tileset
    {
        #region Fields

        /// <summary>
        /// La texture du tileset
        /// </summary>
        private Texture2D image;

        /// <summary>
        /// La largeur des tiles, en pixels
        /// </summary>
        private int tileWidth;

        /// <summary>
        /// La hauteur des tiles, en pixels
        /// </summary>
        private int tileHeight;

        /// <summary>
        /// Le nombre de tiles en largeur
        /// </summary>
        private int tilesWide;

        /// <summary>
        /// Le nombre de tiles en hauteur
        /// </summary>
        private int tilesHigh;

        /// <summary>
        /// Tableau de rectangles qui décriront la zone de chaque tile
        /// </summary>
        private Rectangle[] sourceRectangles;

        #endregion

        #region Properties

        /// <summary>
        /// Récupère et définit la texture du tileset
        /// </summary>
        public Texture2D Image
        {
            get { return image; }
            set { image = value; }
        }

        /// <summary>
        /// Récupère et définit la largeur des tiles, en pixel
        /// </summary>
        public int TileWidth
        {
            get { return tileWidth; }
            set { tileWidth = value; }
        }

        /// <summary>
        /// Récupère et définit la hauteur des tiles, en pixels
        /// </summary>
        public int TileHeight
        {
            get { return tileHeight; }
            set { tileHeight = value; }
        }

        /// <summary>
        /// Récupère et définit le nombre de tiles en largeur
        /// </summary>
        public int TilesWide
        {
            get { return tilesWide; }
            set { tilesWide = value; }
        }

        /// <summary>
        /// Récupère et définit le nombre de tiles en hauteur
        /// </summary>
        public int TilesHigh
        {
            get { return tilesHigh; }
            set { tilesHigh = value; }
        }

        /// <summary>
        /// Récupère le tableau des rectangles sources pour chaque tileset
        /// </summary>
        public Rectangle[] SourceRectangles
        {
            get { return (Rectangle[])sourceRectangles.Clone(); } // Pour éviter de modifier les rectangles sources en mémoire
        }

        #endregion

        #region Constructor

        /// <summary>
        /// Construit un tileset selon une image, la taille des tiles et sa taille
        /// </summary>
        /// <param name="image">La texture du tileset</param>
        /// <param name="tileWidth">La largeur des tiles en pixels</param>
        /// <param name="tileHeight">La hauteur des tiles en pixels</param>
        /// <param name="tilesWide">Le nombre de tiles en largeur</param>
        /// <param name="tilesHigh">Le nombre de tiles en hauteur</param>
        public Tileset(Texture2D image, int tileWidth, int tileHeight, int tilesWide, int tilesHigh)
        {
            Image = image;
            TileWidth = tileWidth;
            TileHeight = tileHeight;
            TilesWide = tilesWide;
            TilesHigh = tilesHigh;

            int tiles = tilesWide * tilesHigh; // Nombre de tiles au total

            sourceRectangles = new Rectangle[tiles]; // Création de la table des rectangles avec le bon nombre de rectangles

            int tile = 0; // Numéro de la tile dans la table des rectangles

            for (int y = 0; y < tilesHigh; y++)
            {
                for (int x = 0; x < tilesWide; x++)
                {
                    sourceRectangles[tile] = new Rectangle(  // Création de chaque rectangle source des tiles
                        x * tileWidth,   // Coordonnée x
                        y * tileHeight,  // Coordonéée y
                        tileWidth,       // Largeur
                        tileHeight       // Hauteur
                        );
                    tile++;
                }
            }
        }

        #endregion
    }
}
﻿using System;
using System.IO;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Collections;

namespace m_test1_hugo.Class.Tile_Engine
{
    /// <summary>
    /// Décrit une couche de la carte, qui pourra être superposée pour créer
    /// des effets graphiques et jouer sur la transparence des tiles
    /// </summary>
    public class MapLayer
    {
        
        #region Fields

        /// <summary>
        /// Le tableau représentant la carte, construit avec des tiles.
        /// </summary>
        private Tile[,] map;

        private static string path = Game1.IsRelease ? "Content/" : "../../../../Content/";

        #endregion

        #region Properties

        /// <summary>
        /// La largeur de la couche de la map
        /// </summary>
        public int Width
        {
            get { return map.GetLength(1); }
        }

        /// <summary>
        /// La hauteur de la couche de la map
        /// </summary>
        public int Height
        {
            get { return map.GetLength(0); }
        }

        #endregion

        #region Constructors

        /// <summary>
        /// Construit une couche de carte selon une carte de tile pré-existante
        /// </summary>
        /// <param name="map">Un tableau de tiles décrivant la carte</param>
        public MapLayer(Tile[,] map)
        {
            this.map = (Tile[,])map.Clone();      
        }

        /// <summary>
        /// Construit une couche vide selon une taille
        /// </summary>
        /// <param name="width">La largeur de la couche</param>
        /// <param name="height">La hauteur de la couche</param>
        public MapLayer(int width, int height)
        {
            map = new Tile[height, width];

            for (int y = 0; y < height; y++)      
            {                                     
                for (int x = 0; x < width; x++)   
                {                                 
                    map[y, x] = new Tile(0, 0);   
                }
            }
        }

        /// <summary>
        /// Construit une couche de carte selon un module stocké dans Content/maps
        /// </summary>
        /// <param name="module">Le nom du fichier, sans l'exstension</param>
        public MapLayer(string module)
        {
            using (var stream = new StreamReader(path + module + ".txt")) // Ouverture du fichier texte qui contient le module
            {
                string line = stream.ReadToEnd();                // Lecture du fichier entier
                string[] values_string = line.Split(';');        // Split du fichier avec des ;
                var values = new int[values_string.Length];      // Création du tableau de valeurs
                for (int j = 0; j < values_string.Length; j++)   // Boucle pour transformer les strings en int
                {
                    values[j] = int.Parse(values_string[j]);
                }

                map = new Tile[values[0], values[1]];            // Deux premières valeurs du fichier : taille du module
                
                int i = 2;                                       

                for (int y = 0; y < values[1]; y++)              // Boucle pour assigner les tiles à la map
                {
                    for (int x = 0; x < values[0]; x++)
                    {
                        map[y, x] = new Tile(values[i], 0);
                        i++;
                    }
                }
            }
        }

        /// <summary>
        /// Construit une couche de carte selon plusieurs modules et un ordre aléatoire
        /// </summary>
        /// <param name="modules">Une liste de strings donnant le nom des modules à charger</param>
        /// <param name="module_width">La taille de chaque module</param>
        /// <param name="ordre">L'ordre aléatoire qui sera utilisé pour construire la couche</param>
        public MapLayer(List<String> modules, int module_width, List<int> ordre) // Création d'une carte à partir d'une liste de cartes en mode aléatoire
        {
            // Ne marche qu'avec des modules carrés
            
            Tile[,] tempMap; // Map temporaire
            int map_width;   // Taille de la map
            int map_height;
            if (modules.Count > 1) // Compatibilité avec un seul module
            {
                map_width = module_width * (modules.Count / 2);
                map_height = module_width * (modules.Count / 2);
            }
            else
            {
                map_width = module_width;
                map_height = module_width;
            }

            int k = 0; // Boucle pour cycler à travers les modules
            int map_index_x = 0; // Index x dans la map finale
            int map_index_y = 0; // Index y dans la map finale

            int[][] rawMaps = new int[modules.Count][]; // Création du tableau de tableaux

            foreach (String module in modules) // Boucle à travers les modules 
            {
                using (var stream = new StreamReader(path + module + ".txt")) // Ouverture du fichier texte qui contient le module
                {
                    string line = stream.ReadToEnd();
                    string[] values_string = line.Split(';');
                    var values = new int[values_string.Length];
                    for (int j = 0; j < values_string.Length; j++)
                    {
                        values[j] = int.Parse(values_string[j]);
                    }
                    rawMaps[k] = values;
                    k++;
                }
            }

            /*F:\Dev\7 - menu - refont\m_test1_hugo\m_test1_hugo\Content\maps\grassy32
            F:\Dev\7 - menu - refont\m_test1_hugo\Content\maps\grassy32*/

                    tempMap = new Tile[map_width, map_height]; // Instanciation de la map temporaire

            foreach (int index in ordre)
            {
                int map_index = 2;
                for (int y = map_index_y; y < map_index_y + rawMaps[index][1]; y++)
                {
                    for (int x = map_index_x; x < map_index_x + rawMaps[index][0]; x++)
                    {
                        tempMap[y, x] = new Tile(rawMaps[index][map_index], 0);
                        map_index++;
                    }
                }

                map_index_x += rawMaps[index][0];
                if (map_index_x >= map_width)
                {
                    map_index_y += rawMaps[index][1];
                    map_index_x = 0;
                }

            }

            map = tempMap;
        }

        #endregion

        #region Methods

        /// <summary>
        /// Donne une tile de la map en prenant son x et son y
        /// </summary>
        /// <param name="x">Coordonnée x de la Tile</param>
        /// <param name="y">Coordonnée y de la Tile</param>
        /// <returns>Une instance de la classe Tile correspondant à celle indiquée par x et y</returns>
        public Tile getTile(int x, int y)
        {
            return map[y, x];
        }

        /// <summary>
        /// Change la tile aux coordonnées précisées
        /// </summary>
        /// <param name="x">Coordonnée x de la Tile</param>
        /// <param name="y">Coordonnée y de la Tile</param>
        /// <param name="tile">Tile à placer dans la map</param>
        public void setTile(int x, int y, Tile tile)
        {
            map[y, x] = tile;
        }


        /// <summary>
        /// Change la tile aux coordonnées précisées
        /// </summary>
        /// <param name="x">Coordonnée x de la Tile</param>
        /// <param name="y">Coordonnée y de la Tile</param>
        /// <param name="tileIndex">Numéro de la Tile dans le tileset</param>
        /// <param name="tileset">Numéro du tileset</param>
        public void setTile(int x, int y, int tileIndex, int tileset)
        {
            map[y, x] = new Tile(tileIndex, tileset);
        }

        #endregion
    }
}
﻿using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using m_test1_hugo.Class.Main;
using System.IO;

namespace m_test1_hugo.Class.Tile_Engine
{
    /// <summary>
    /// Décrit la carte du jeu
    /// </summary>
    public class TileMap
    {
        #region Fields

        private static string path = Game1.IsRelease ? "Content/collisions/" : "../../../../Content/collisions/";

        /// <summary>
        /// Liste des tilesets utilisés dans la carte
        /// </summary>
        private List<Tileset> tilesets;

        /// <summary>
        /// Liste des couches de la carte
        /// </summary>
        private List<MapLayer> mapLayers;

        /// <summary>
        /// La couche de collision de la carte
        /// </summary>
        private CollisionLayer collisionLayer;

        /// <summary>
        /// La couche de collision des balles
        /// </summary>
        private CollisionLayer bulletCollisionLayer;

        /// <summary>
        /// La taille des tiles
        /// </summary>
        private int tilesize;

        #endregion

        #region Properties

        /// <summary>
        /// Récupère la couche de collision entre le joueur et la carte
        /// </summary>
        public CollisionLayer PCollisionLayer
        {
            get { return collisionLayer; }
        }

        /// <summary>
        /// Récupère la couche de collision entre les balles et la carte
        /// </summary>
        public CollisionLayer BCollisionLayer
        {
            get { return bulletCollisionLayer; }
        }

        /// <summary>
        /// Récupère et définit la taille des tiles de la carte
        /// </summary>
        public int Tilesize
        {
            get { return tilesize; }
            set { tilesize = value; }
        }

        /// <summary>
        /// Récupère et définit la liste des couches de la map
        /// </summary>
        public List<MapLayer> MapLayers
        {
            get
            {
                return mapLayers;
            }

            set
            {
                mapLayers = value;
            }
        }

        #endregion

        #region Constructors

        /// <summary>
        /// Construit une carte de jeu selon une liste de tilesets et une liste de couches de carte
        /// </summary>
        /// <param name="tilesets"></param>
        /// <param name="mapLayers"></param>
        public TileMap(List<Tileset> tilesets, List<MapLayer> mapLayers)
        {
            // Ajout des tilesets
            this.tilesets = tilesets;

            // Ajout des maplayers
            this.MapLayers = mapLayers;

            // Ajout de la collision
            collisionLayer = new CollisionLayer(mapLayers[0].Height, mapLayers[0].Width);
            bulletCollisionLayer = new CollisionLayer(mapLayers[0].Height, mapLayers[0].Width);
            foreach (MapLayer maplayer in mapLayers)
            {
                ProcessColisionLayer(maplayer);
            }
        }

        /// <summary>
        /// Construit une carte de jeu avec un tileset et une carte de jeu
        /// </summary>
        /// <param name="tileset"></param>
        /// <param name="mapLayer"></param>
        public TileMap(Tileset tileset, MapLayer mapLayer)
        {
            // Ajout du tileset
            tilesets = new List<Tileset>();
            tilesets.Add(tileset);

            // Ajout des maplayers
            MapLayers = new List<MapLayer>();
            MapLayers.Add(mapLayer);

            // Ajout de la collision
            collisionLayer = new CollisionLayer(MapLayers[0].Height, MapLayers[0].Width);
            bulletCollisionLayer = new CollisionLayer(MapLayers[0].Height, MapLayers[0].Width);
            foreach (MapLayer maplayer in MapLayers)
            {
                ProcessColisionLayer(maplayer);
            }

        }

        #endregion

        #region Methods


        /// <summary>
        /// Dessine la map à l'écrab
        /// </summary>
        /// <param name="spritebatch">Spritebatch utilisé pour dessiner</param>
        public void Draw(SpriteBatch spritebatch)
        {
            Rectangle destination = new Rectangle(0, 0, TileEngine.TileWidth, TileEngine.TileHeight); // Utiliser un seul rectangle pour optimiser les calculs ; seuls les coordonnées changent
            Tile tile; // Utiliser une seule tile pour optimiser les calculs

            foreach (MapLayer layer in MapLayers) // Possibilité de superposer des maps (meilleurs effets graphiques)
            {
                for (int y = 0; y < layer.Height; y++)
                {
                    destination.Y = y * TileEngine.TileHeight; // Calcul de la position Y du rectangle de destination
                    for (int x = 0; x < layer.Width; x++)
                    {
                        tile = layer.getTile(x, y); // Récupération de la tile en cours de traitement

                        destination.X = x * TileEngine.TileWidth; // Calcul de la position X du rectangle de destination

                        spritebatch.Draw( // Dessin de la map
                            tilesets[tile.Tileset].Image, // Texture du tileset
                            destination, // Rectangle de destination
                            tilesets[tile.Tileset].SourceRectangles[tile.TileIndex], // Rectangle source de la Tile
                            Color.White // Pas d'effet coloré
                        );
                    }
                }
            }
        }

        /// <summary>
        /// Charge les valeurs de collisions des blocs
        /// </summary>
        /// <param name="fileName">Le nom du fichier</param>
        /// <returns>Les valeurs de collision</returns>
        public int[] loadCollisionFile(string fileName)
        {
            string line;
            string[] lines;
            int[] res;
            //Console.WriteLine("../../../../Content/collisions/" + fileName + ".txt");
            using (var stream = new StreamReader(path + fileName + ".txt"))
            {
                line = stream.ReadToEnd();
                lines = line.Split(';');
                res = new int[lines.Length];

                for (int i = 0; i < lines.Length; i++)
                {
                    res[i] = int.Parse(lines[i]);
                }
            }

            return res;
        }

        /// <summary>
        /// Traite la collision
        /// </summary>
        /// <param name="layer">Couche de la map</param>
        private void ProcessColisionLayer(MapLayer layer)
        {
            int[] bulletCollisionValues;
            int[] spriteCollisionValues;
            int[] bridgeCollisionValues;

            bulletCollisionValues = loadCollisionFile("bulletcollision");
            spriteCollisionValues = loadCollisionFile("spritecollision");
            bridgeCollisionValues = loadCollisionFile("bridgecollision");

            for (int y = 0; y < layer.Height; y++)
            {
                for (int x = 0; x < layer.Width; x++)
                {
                    // Balles
                    if (bulletCollisionValues.Contains(layer.getTile(x, y).TileIndex))
                        bulletCollisionLayer.SetTile(x, y, false);

                    if (spriteCollisionValues.Contains(layer.getTile(x, y).TileIndex))
                        collisionLayer.SetTile(x, y, false);
                    
                    if (bridgeCollisionValues.Contains(layer.getTile(x, y).TileIndex))
                    {
                        bulletCollisionLayer.SetTile(x, y, true);
                        collisionLayer.SetTile(x, y, true);
                    }
                }
            }
        }

        /// <summary>
        /// Récupère la largeur de la carte
        /// </summary>
        /// <returns></returns>
        public int GetWidth()
        {
            return MapLayers[0].Width;
        }

        /// <summary>
        /// Récupère la hauteur de la carte
        /// </summary>
        /// <returns></returns>
        public int GetHeight()
        {
            return MapLayers[0].Height;
        }

        #endregion
    }
}
﻿using m_test1_hugo.Class.Main;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Audio;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace m_test1_hugo.Class.Weapons
{
    class Assault : Weapon
    {
        public override Vector2 Position
        {
            get { return Holder.Center; }
        }

        public override void LoadContent(ContentManager content)
        {
            Name = "M4A1-s";
            texture = content.Load<Texture2D>("weapons/"+Name);
        }

        public Assault()
            :base()
        {
            this.ReloadingTime = 2000;  // millisecondes
            this.RearmingTime = 115; // millisecondes
            this.MagazineSize = 25;
            this.tir = Weapon.methodeTir.auto;
            this.CurrentAmmo = MagazineSize;
            this.Damages = 18;
            this.Range = 1000;
            this.bulletSpeed = 40;
            this.bulletSprite = "ClassicBullet";
            this.MovingMalus = 0;
            this.accuracy_malus = 0.06;
        }
    }
}
﻿using m_test1_hugo.Class.Main;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework;
using m_test1_hugo.Class.Main.interfaces;
using Microsoft.Xna.Framework.Audio;
using m_test1_hugo.Class.Main.Menus.pages;

namespace m_test1_hugo.Class.Weapons
{
    class Bullet : Sprite, TileCollision
    {
        private SoundEffect Hitmarker;
        private float parcouru;

        public float _angleTir;

        public float Inc_X
        {
            get
            {
                return (float)(Math.Cos(_angleTir)) * _weapon.bulletSpeed;
            }
        }

        public float Inc_Y
        {
            get
            {
                return (float)(Math.Sin(_angleTir)) * _weapon.bulletSpeed;
            }
        }

        public Vector2 Inc_vector
        {
            get
            {
                if (sensPositif)
                    return new Vector2(Inc_X, Inc_Y);
                else
                    return new Vector2(-Inc_X, -Inc_Y);
            }
        }

        public bool sensPositif;

        public Vector2 Origin;

        public static List<Bullet> BulletList = new List<Bullet> { };

        public Weapon _weapon;

        public Bullet(Weapon weapon, float angleTir, bool isNew)
        {
            this._weapon = weapon;
            this._angleTir = angleTir;
            this.Origin = weapon.CanonOrigin;
            Position = Origin;
            sensPositif = weapon.Holder.CO > 0;
            LoadContent(Game1.Content);
            BulletList.Add(this);
            if (GamePage.client != null && isNew)
            {
                GamePage.client.SendNewBullet(weapon.Holder.Id, angleTir);
            }
        }

        public Bullet(Weapon weapon, float angleTir, bool sens, bool isNew)
        {
            this._weapon = weapon;
            this._angleTir = angleTir;
            this.Origin = weapon.CanonOrigin;
            Position = Origin;
            sensPositif = sens;
            LoadContent(Game1.Content);
            BulletList.Add(this);
            if (GamePage.client != null && isNew)
            {
                GamePage.client.SendNewBullet(weapon.Holder.Id, angleTir);
            }
        }

        public override void LoadContent(ContentManager content)
        {
            this.texture = content.Load<Texture2D>("Bullets/" + _weapon.bulletSprite);
            Hitmarker = content.Load<SoundEffect>("audio/weapons/hitmarker/hitmarker");
        }


        public void Update(GameTime gametime, int tileSize, int mapWidth, int mapHeight, CollisionLayer collisionLayer)
        {
            if (Position.X <= 0 || Position.Y <= 0 || TileCollision(this, tileSize, mapWidth, mapHeight, collisionLayer, 0) || parcouru >= _weapon.Range)
                BulletList.Remove(this);
            else
            {
                Position += Inc_vector;
                parcouru = (float)(Math.Sqrt(Math.Pow(Origin.X - Position.X, 2) + Math.Pow(Origin.Y - Position.Y, 2)));

                for (var j = 0; j < GamePage.PlayersToDraw.Count; j++)
                {
                    if (GamePage.PlayersToDraw[j].team._teamNumber != _weapon.Holder.team._teamNumber)
                    {
                        Player currentCharacter = GamePage.PlayersToDraw[j];

                        if (this.SpriteCollision(currentCharacter.destinationRectangle))
                        {
                            /*if(_weapon is shotgun && parcouru > 300)
                            {
                                currentCharacter.Health -= (int)(this._weapon.Damages - parcouru /20);
                                Console.WriteLine(parcouru);
                            }
                            else*/
                            if (this._weapon.Damages >= currentCharacter.Health)
                            {
                                _weapon.Holder.Kills++;
                                if(_weapon.Holder == GamePage.player)
                                {
                                    _weapon.Holder.Serie++;
                                    if(_weapon.Holder.Deaths %2 == 0)
                                        _weapon.Holder.PlayVoiceKill(_weapon.Holder.Serie - 1);
                                }
                                
                                _weapon.Holder.team.TeamKills++;
                            }
                             
                            currentCharacter.Health -= (this._weapon.Damages);
                            Hitmarker.Play(0.4f, 0, 0);
                            BulletList.Remove(this);
                        }
                    }
                }
            }
        }
        public void Update(GameTime gametime, int tileSize, int mapWidth, int mapHeight)
        {
            if (Position.X <= 0 || Position.Y <= 0  || parcouru >= _weapon.Range)
                BulletList.Remove(this);
            else
            {
                Position += Inc_vector;
                parcouru = (float)(Math.Sqrt(Math.Pow(Origin.X - Position.X, 2) + Math.Pow(Origin.Y - Position.Y, 2)));
            }
        }

        public bool SpriteCollision(Rectangle objet)
        {
            return (this.Bounds.Intersects(objet));
        }

        public bool TileCollision(Sprite objet1, int tileSize, int mapWidth, int mapHeight, CollisionLayer collisionLayer, int direction)
        {
            int nextX, nextY, currentX, currentY;

            if (sensPositif)
            {
                nextX = (int)Math.Ceiling((this.Center.X + (int)Inc_X) / tileSize) - 1;
                nextY = (int)Math.Ceiling((this.Center.Y + (int)Inc_Y) / tileSize) - 1;
            }
            else
            {
                nextX = (int)Math.Ceiling((this.Center.X - (int)Inc_X) / tileSize) - 1;
                nextY = (int)Math.Ceiling((this.Center.Y - (int)Inc_Y) / tileSize) - 1;
            }
            currentX = (int)Math.Ceiling((this.Center.X) / tileSize) - 1;
            currentY = (int)Math.Ceiling((this.Center.Y) / tileSize) - 1;
            //Console.WriteLine("currentX: " + nextX + "currentY: " + nextY);
            //Console.WriteLine("nextX: " + nextTileX+ "nextY: " + nextTileY);

            if (nextX > (mapWidth - 1) || nextY > (mapHeight - 1) || nextY <= 1 || nextX <= 1)
            {
                return false;
            }

            else
            {
                return (!collisionLayer.GetTile(nextX, nextY) || !collisionLayer.GetTile(currentX, currentY));
            }

        }

       
        public new void Draw(SpriteBatch spriteBatch)
        {
            spriteBatch.Draw(texture, Position, null, Color.White, _angleTir, Vector2.Zero, 1.0f, SpriteEffects.None, 0f);
        }
    }
}﻿using m_test1_hugo.Class.Main;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Audio;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace m_test1_hugo.Class.Weapons
{
    class Fal : Weapon
    {

        public override Vector2 Position
        {
            get { return Holder.Center; }
        }

        public override void LoadContent(ContentManager content)
        {
            Name = "FN-FAL";
            texture = content.Load<Texture2D>("weapons/"+Name);
        }

        public Fal()
            :base()
        {
            this.ReloadingTime = 2000;  // millisecondes
            this.RearmingTime = 10; // millisecondes
            this.MagazineSize = 21;
            this.tir = methodeTir.semiAuto;
            this.CurrentAmmo = MagazineSize;
            this.Damages = 22;
            this.Range = 1100;
            this.bulletSpeed = 38;
            this.bulletSprite = "ClassicBullet";
            this.MovingMalus = 0;
            this.accuracy_malus = 0.07;
        }
        public Fal(Player Holder)
            :this()
        {
            this.Holder = Holder;
        }

    }
}
﻿using m_test1_hugo.Class.Main;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Audio;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace m_test1_hugo.Class.Weapons
{
    class Glock : Weapon
    {
        
        public override Vector2 Position
        {
            get { return Holder.Center; }
        }

        public override void LoadContent(ContentManager content)
        {
            Name = "Glock-17";
            texture = content.Load<Texture2D>("weapons/"+Name);
        }

        public Glock()
        {
            LoadContent(Game1.Content);
            this.ReloadingTime = 1200;  // millisecondes
            this.RearmingTime = 95; // millisecondes
            this.MagazineSize = 14;
            this.tir = methodeTir.semiAuto;
            this.CurrentAmmo = MagazineSize;
            this.Damages = 13;
            this.Range = 800;
            this.bulletSpeed = 30;
            this.bulletSprite = "ClassicBullet";
            this.MovingMalus = -1;
            this.accuracy_malus = 0.07;
            weaponSound = Game1.Content.Load<SoundEffect>("audio/weapons/" + this.Name);
        }
        public Glock(Player Holder)
            :this()
        {
            this.Holder = Holder;
        }
    }
}
﻿using m_test1_hugo.Class.Main;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Audio;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace m_test1_hugo.Class.Weapons
{
    class M16: Weapon
    {
        public override Vector2 Position
        {
            get { return Holder.Center; }
        }

        public override void LoadContent(ContentManager content)
        {
            Name = "M16";
            texture = content.Load<Texture2D>("weapons/"+Name);
        }


        public M16()
            :base()
        {
            this.ReloadingTime = 2000;  // millisecondes
            this.RearmingTime = 600; // millisecondes
            this.MagazineSize = 21;
            this.tir = methodeTir.rafale;
            this.CurrentAmmo = MagazineSize;
            this.Damages = 17;
            this.Range = 1000;
            this.bulletSpeed = 32;
            this.bulletSprite = "ClassicBullet";
            this.MovingMalus = 0;
            this.accuracy_malus = 0.1;
            EndSound = Game1.Content.Load<SoundEffect>("audio/weapons/" + Name + "_end");// + this.Name);;
        }
    }
}
﻿using m_test1_hugo.Class.Main;
using m_test1_hugo.Class.Main.interfaces;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Audio;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace m_test1_hugo.Class.Weapons
{
    class Minigun : Weapon
    {
        public override Vector2 Position
        {
            get { return Holder.Center; }
        }

        public override void LoadContent(ContentManager content)
        {
            Name = "minigun";
            texture = content.Load<Texture2D>("weapons/"+Name);
        }

        public Minigun()
            :base()
        { 
            this.ReloadingTime = 4000;  // millisecondes
            this.RearmingTime = 20 ; // millisecondes
            this.MagazineSize = 95;
            this.CurrentAmmo = MagazineSize;
            this.Damages = 8;
            this.tir = methodeTir.auto;
            this.Range = 800;
            this.bulletSpeed = 20;
            this.bulletSprite = "ClassicBullet";
            this.MovingMalus = 2;
            this.accuracy_malus = 0.1;
        }
    }
}
﻿using m_test1_hugo.Class.Main;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Audio;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace m_test1_hugo.Class.Weapons
{
    class Shotgun : Weapon
    {
        public override Vector2 Position
        {
            get { return Holder.Center; }
        }

        public override void LoadContent(ContentManager content)
        {
            Name = "shotgun";
            texture = content.Load<Texture2D>("weapons/"+Name);
        }

        public Shotgun()
        {
            this.ReloadingTime = 2000;  // millisecondes  2000
            this.RearmingTime = 1000; // millisecondes   1000
            this.MagazineSize = 4;
            this.CurrentAmmo = MagazineSize;
            this.Damages = 45;
            this.tir = methodeTir.semiAuto;
            this.Range = 470;
            this.bulletSpeed = 40;
            this.bulletSprite = "ClassicBullet";
            this.MovingMalus = 0;
            weaponSound = Game1.Content.Load<SoundEffect>("audio/weapons/" + this.Name);
        }
    }
}
﻿using m_test1_hugo.Class.Main;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Content;
using System;
using Microsoft.Xna.Framework.Input;
using Microsoft.Xna.Framework.Audio;

namespace m_test1_hugo.Class.Weapons
{
    public class Sniper : Weapon
    {
      
        // Virer le new et mettre override pour écraser le getter
        public override Vector2 Position
        {
            get { return Holder.Center; }
        }

        public override void LoadContent(ContentManager content)
        {
            Name = "sniper";
            texture = content.Load<Texture2D>("weapons/"+Name);
        }

        public Sniper()
            :base()
        {
            this.ReloadingTime = 2500;  // millisecondes
            this.RearmingTime = 1200; // millisecondes
            this.MagazineSize = 5;
            this.CurrentAmmo = MagazineSize;
            this.Damages = 100;
            this.tir = methodeTir.semiAuto;
            this.Range = 1000;
            this.bulletSpeed = 60;
            this.bulletSprite = "ClassicBullet";
            this.MovingMalus = 0;
            this.accuracy_malus = 0;
        }

        public Sniper(Player Holder)
            :this()
        {
            this.Holder = Holder;
        }
    }
}﻿using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using System;
using System.Collections.Generic;
using Microsoft.Xna.Framework.Content;
using m_test1_hugo.Class.Weapons;
using Microsoft.Xna.Framework.Audio;

namespace m_test1_hugo.Class.Main
{
    
    public abstract class Weapon : Sprite
    {

        public static Weapon[] List = new Weapon[] { new Assault(), new Shotgun(), new Minigun(), new Glock(), new Fal(), new M16(), new Sniper() };
        public static Dictionary<string, Weapon> WeaponDictionnary = new Dictionary<string, Weapon>();
        public enum methodeTir { auto, semiAuto, rafale };
        #region Position / Sprite

        public Vector2 _canonOrigin;
        public Vector2 CanonOrigin
        {
            get { return Holder.Center; }
        }
        
        private Texture2D sprite;
        public Texture2D Sprite
        {
            set { sprite = value; }
            get { return sprite; }
        }

        #endregion

        public bool rafale;
        public int rafaleCount;
        public DateTime initTempo;
        public int tempoDuration = 80; // milliseconds rafales
        public SoundEffect weaponSound;
        public SoundEffect EndSound;

        public methodeTir tir;

        private string name;
        public string Name
        {
            get { return name; }
            set { name = value; }
        }

        public double accuracy_malus;

        private Player _holder;
        public Player Holder
        {
            get { return this._holder; }
            set
            {
                // On récupère le parent
                this._holder = value;
            }
        }

        private float range;
        public float Range
        {
            get { return range; }
            set {range = value;}
        }

        private int magazineSize;
        public int MagazineSize
        {
            get { return magazineSize;}
            set { magazineSize = value; }
        }

        // temps de rearmement
        private int rearmingTime;
        public int RearmingTime
        {
            get { return rearmingTime; }
            set { rearmingTime = value; }
        }

        private int currentAmmo;
        public int CurrentAmmo
        {
            get { return currentAmmo;}

            set { currentAmmo = value; }
        }

        #region rechargement / rearmement
        
        public bool isEmpty
        {
            get { return currentAmmo == 0; }
        }

        public bool isFull
        {
            get { return currentAmmo == magazineSize; }
        }

        // Temps de recharge
        private int reloadingTime; // *1000
        public int ReloadingTime
        {
            get
            {
                return reloadingTime;
            }

            set
            {
                reloadingTime = value;
            }
        }

        // Permettra de savoir si l'on a besoin de recharger
        private bool needReloading;
        public bool NeedReloading
        {
            get { return needReloading; }
            set { needReloading = value; }
        }

        // permettra de savoir si l'on est en train de rearmer
        private bool needRearming;
        public bool NeedRearming
        {
            get { return needRearming; }
            set { needRearming = value; }
        }
        
        #endregion

        // poids de l'arme
        private int _movingMalus;
        public int MovingMalus
        {
            get { return _movingMalus; }
            set { _movingMalus = value; }
        }

        private int damages;
        public int Damages
        {
            get { return damages+Holder.DamageBonus; }
            set { damages = value; }
        }

        public string bulletSprite;

        public float bulletSpeed
        {
            get;
            set;
        }

        public int getBulletPerShot()
        {
            return tir == methodeTir.auto || tir == methodeTir.semiAuto ? 3 : 3;
        }

        public new void Draw(SpriteBatch spritebatch)
        {   
            if (Holder.CO <= 0)// cote oppose holder ( voir dans les attributs, et faire un schema si besoin)
            {
                spritebatch.Draw(this.texture, Position, null, Color.White, Holder.MouseRotationAngle, new Vector2(0, this.Height / 2), -1.0f, SpriteEffects.FlipVertically, 0f); // mettre en comm pour tester ce que ca fait 
            }
            else
            {
                spritebatch.Draw(this.texture, Position, null, Color.White, Holder.MouseRotationAngle, new Vector2(0, this.Height / 2), 1.0f, SpriteEffects.None, 0f);
            }

            if (this.rafale)
            {
                if (this.rafaleCount < 2)
                {
                    if (DateTime.Now > initTempo.AddMilliseconds(tempoDuration))
                    {
                        new Bullet(this, Holder.MouseRotationAngle, true);
                        this.weaponSound.Play();
                        this.currentAmmo--;
                        rafaleCount++;
                        initTempo = DateTime.Now;
                    }
                }
                else
                {
                    rafale = false;
                    EndSound.Play();
                }
            }
        }

       
        public Weapon()
        {
            LoadContent(Game1.Content);
            weaponSound = Game1.Content.Load<SoundEffect>("audio/weapons/" + Name);// + this.Name);
        }

        public Weapon(Player player)
            :this()
        {
            this.Holder = player;
        }


        public static void InitDictionary()
        {
            WeaponDictionnary.Add("M4A1-s", new Assault());
            WeaponDictionnary.Add("FN-FAL", new Fal());
            WeaponDictionnary.Add("Glock-17", new Glock());
            WeaponDictionnary.Add("M16", new M16());
            WeaponDictionnary.Add("shotgun", new Shotgun());
            WeaponDictionnary.Add("sniper", new Sniper());
            WeaponDictionnary.Add("minigun", new Minigun());
        }
    }
}
﻿using entrainementProjet1.Class.Main;
using m_test1_hugo.Class.Main;
using m_test1_hugo.Class.Main.outils_dev_jeu.Affects;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace m_test1_hugo.Class.clothes
{
    class Boots:Cloth
    {
        #region attributs
        private int bonus;
        public override int Bonus
        {
            get
            {
                return bonus;
            }
            set
            {
                this.bonus = value;
            }
        }

        #endregion

        public override Vector2 Position
        {
            get { return new Vector2(9, 257); }
        }

        public Boots(string name, int moveSpeedBonus)
            :base(name, moveSpeedBonus)
        {
            this.Bonus = moveSpeedBonus;
            this.clothName = name;
            LoadContent(Game1.Content);
        }

        public override void LoadContent(ContentManager content)
        {
            texture = content.Load<Texture2D>("clothes/boots/" + clothName);
        }

        public override void interract(Player player)
        {
            CharacterAffect.increaseMoveSpeed(player, 4);
            player.ClothesList[2] = this;
        }

        public override void TakeOff(Player player)
        {
            if (player.ClothesList[2] != null)
            {
                CharacterAffect.decreaseMoveSpeed(player, 4);
                player.ClothesList[2] = null;
            }
        }
    }
}
﻿using entrainementProjet1.Class.Main;
using m_test1_hugo.Class.Main;
using m_test1_hugo.Class.Main.outils_dev_jeu.Affects;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace m_test1_hugo.Class.clothes
{
    class Pant:Cloth
    {

        #region attributs
        private int bonus;
        public override int Bonus
        {
            get
            {
                return bonus;
            }
            set
            {
                this.bonus = value;
            }
        }

        #endregion

        public override Vector2 Position
        {
            get { return new Vector2(20, 175); }
        }

        public Pant(string name, int healthBonus)
            :base(name, healthBonus)
        {
            this.Bonus = healthBonus;
            this.clothName = name;
            LoadContent(Game1.Content);
        }

        public override void LoadContent(ContentManager content)
        {
            texture = content.Load<Texture2D>("clothes/pants/" + clothName);
        }

        public override void interract(Player player)
        {
            //player.ClothesList[1].TakeOff(player);
            player.ClothesList[1] = this;
            //CharacterAffect.increaseHealth(player, Bonus);
        }

        public override void TakeOff(Player player)
        {
            if (player.ClothesList[1] != null)
            {
                //CharacterAffect.decreaseHealth(player, Bonus);
                player.ClothesList[1] = null;
            }
        }
    }
}
﻿using entrainementProjet1.Class.Main;
using m_test1_hugo.Class.Main;
using m_test1_hugo.Class.Main.outils_dev_jeu.Affects;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace m_test1_hugo.Class.clothes
{
    public class Shirt : Cloth
    {
        #region attributs
        private int bonus;
        public override int Bonus
        {
            get
            {
                return bonus;
            }
            set
            {
                this.bonus = value;
            }
        }

        #endregion

        // public delegate void Bonus(Player player, int bonus);

        public override Vector2 Position
        {
            get { return new Vector2(7, 95); }
        }

        public Shirt(string name, int damageBonus)
            :base(name, damageBonus)
        {
            this.Bonus = damageBonus;
            this.clothName = name;
            LoadContent(Game1.Content);
        }

        public override void LoadContent(ContentManager content)
        {
            texture = content.Load<Texture2D>("clothes/shirts/" + clothName);
        }

        public override void interract(Player player)
        {
            player.ClothesList[0].TakeOff(player);
            CharacterAffect.increaseDamages(player, bonus);
        }

        public override void TakeOff(Player player)
        {
            if (player.ClothesList[0] != null)
            {
                CharacterAffect.decreaseDamages(player, bonus);
                player.ClothesList[0] = null;
            }
        }
    }
}

/*public override void interract(Player player)  POUR LES T-SHIRT
{
    player.ClothesList[0] = this;

    player.MaxHealth = player.classe.Health + healthBonus;
    player.Health = player.MaxHealth;
*/﻿using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace m_test1_hugo.Class.Main.Menus
{
    public abstract class MenuPage
    {
        public List<Button> buttons = new List<Button>();

        public abstract MenuPage Action();
        public abstract void Update();
        public abstract void Draw(SpriteBatch spriteBatch);
    }
}

﻿using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace m_test1_hugo.Class.Main.Menus.healthBar
{
    public class HealthBar:Sprite
    {
        //width : 66, height : 6
        public Texture2D lifeRectangle;
        int lifeRectangleWidth;
        public Player Holder;
        Color color;

        public object ScreenManager { get; private set; }

        public override void LoadContent(ContentManager content)
        {
            texture = content.Load<Texture2D>("players/healthBar");
            lifeRectangle = content.Load<Texture2D>("players/green");
        }

        public void Update(GameTime gameTime)
        {
            Position = new Vector2(Holder.Position.X-Holder.Width/4, Holder.Position.Y-20);
            lifeRectangleWidth = Holder.Health * 66 / Holder.MaxHealth;
            if (lifeRectangleWidth <= 33)
                color = Color.Orange;
            if (lifeRectangleWidth < 18)
                color = Color.Red;
            if(lifeRectangleWidth > 33)
                color = Color.Green;
        }

        public HealthBar(Player Holder)
        {
            this.Holder = Holder;
            LoadContent(Game1.Content);
        }

        public new void Draw(SpriteBatch spriteBatch)
        {
            Update(Game1.gameTime);
            spriteBatch.Draw(texture, Position, Color.White);
            spriteBatch.Draw(lifeRectangle, new Rectangle((int)Position.X+1, (int)Position.Y+1, lifeRectangleWidth, 6), color);
        }

    }
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework;
using m_test1_hugo.Class.Main.outils_dev_jeu.ArmesVignette;
using m_test1_hugo.Class.Bonuses;
using m_test1_hugo.Class.Main.outils_dev_jeu.pics;
using m_test1_hugo.Class.Main.Menus.pages;

namespace m_test1_hugo.Class.Main.overlay
{
    public class Overlay : Sprite
    {
        SpriteFont font; // on définit une police d'écriture pour les mesages liés à l'overlay

        #region messages
        string ammo, health, reloading = "RELOADING" ;
        public string takeWeapon = "Press E again to take this Weapon";
        string pressButton = "Press E to open the secret box !";
        #endregion
        private Player player; // joueur associé à l'overlay (client)
        
        #region positions - size
        Vector2 FooterPosition, ammoPosition, healthPosition;
        float BodyScale;
        #endregion

        Texture2D Body;
        Pics pic;

        public Overlay(Player player)
        {
            this.player = player;
            LoadContent(Game1.Content);
        }

        #region positions    
        Vector2 ReloadingPosition
        {
            get { return new Vector2(Game1.WindowWidth / 2, Game1.WindowHeight / 2); }
        }

        Vector2 weaponPicPosition
        {
            get { return new Vector2(Game1.WindowWidth / 2, Game1.WindowHeight / 2 - 50); }
        }

        Vector2 BodyPosition
        {
            get { return Vector2.Zero; }
        }

        #endregion

        public override void LoadContent(ContentManager content)
        {
            // on charge les textures
            texture = content.Load<Texture2D>("Overlay/footer");
            Body = content.Load<Texture2D>("Overlay/nude");
            font = content.Load<SpriteFont>("font");
            FooterPosition = new Vector2(Game1.WindowWidth / 2 - Width / 2, Game1.WindowHeight - Height);
            ammoPosition = new Vector2(FooterPosition.X + Width - Width/4, FooterPosition.Y + Height /3);
            healthPosition = new Vector2(FooterPosition.X + Width / 7, FooterPosition.Y + Height / 3);
            BodyScale = 1f;
        }
        
        public void Update(GameTime gametime)
        {
            // on récupère les stats joueur + balles dans l'arme
            if(player.weapon != null)
                ammo = player.weapon.CurrentAmmo + " / " + player.weapon.MagazineSize;
            health = player.Health + " / " + player.MaxHealth;
        }

        public new void Draw(SpriteBatch spriteBatch)
        {
            Update(Game1.gameTime);// on met a jour
            spriteBatch.Draw(texture, FooterPosition, Color.White);

            //on dessine toutes les infos
            if (GamePage.player.weapon != null)
            {
                if(ammo != null)
                    spriteBatch.DrawString(font, ammo, ammoPosition, Color.White, 0, Vector2.Zero, 0.26f, SpriteEffects.None, 1f);
            }
                
            spriteBatch.DrawString(font, health.ToString(), healthPosition, Color.White, 0, Vector2.Zero , 0.26f, SpriteEffects.None, 1f);

            if (GamePage.player.weapon != null)
            {
                if (GamePage.player.weapon.NeedReloading)
                    spriteBatch.DrawString(font, reloading, ReloadingPosition, Color.FloralWhite, 0, new Vector2(font.MeasureString(reloading).X / 2, font.MeasureString(reloading).Y), 0.5f, SpriteEffects.None, 1f);
            }

            spriteBatch.Draw(Body, BodyPosition, null, Color.White, 0f, Vector2.Zero, BodyScale, SpriteEffects.None, 1f);

            //on dessine le message si le personnage est sur une "weaponPic"
            #region weaponPics
            for (var i = 0; i < GamePage.PicList.Count; i++)
            {
                if(GamePage.PicList[i] is WeaponPic)
                    pic = (WeaponPic)GamePage.PicList[i];

                else if(GamePage.PicList[i] is ClothPic)
                    pic = (ClothPic)GamePage.PicList[i];

                if (pic.takeMsg)
                {
                    spriteBatch.DrawString(font, takeWeapon, weaponPicPosition, Color.Wheat, 0, new Vector2(font.MeasureString(takeWeapon).X / 2, font.MeasureString(takeWeapon).Y), 0.5f, SpriteEffects.None, 0.2f);
                }
            }
            #endregion

            //on dessine le message si le personnage est sur une "magicBox"
            #region magicBox
            for (var i = 0; i < GamePage.BonusList.Count; i++)
            {
                Bonus bonus = GamePage.BonusList[i];

                if(bonus is MagicBox)
                {
                    MagicBox magicBox = (MagicBox)bonus;
                    if (magicBox.pressButtonMsg)
                    {
                        spriteBatch.DrawString(font, pressButton, weaponPicPosition, Color.Wheat, 0, new Vector2(font.MeasureString(takeWeapon).X / 2, font.MeasureString(takeWeapon).Y), 0.5f, SpriteEffects.None, 0.2f);
                    }
                }
                else if(bonus is ClothBox)
                {
                    ClothBox clothBox = (ClothBox)bonus;
                    if (clothBox.pressButtonMsg)
                    {
                        spriteBatch.DrawString(font, pressButton, weaponPicPosition, Color.Wheat, 0, new Vector2(font.MeasureString(takeWeapon).X / 2, font.MeasureString(takeWeapon).Y), 0.5f, SpriteEffects.None, 0.2f);
                    }
                }  
            }
            #endregion
        }
    }
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework;
using m_test1_hugo.Class.Main.outils_dev_jeu.ArmesVignette;
using m_test1_hugo.Class.Bonuses;
using m_test1_hugo.Class.Main.outils_dev_jeu.pics;
using m_test1_hugo.Class.Main.Menus.pages;
using m_test1_hugo.Class.Characters.Teams;
using Microsoft.Xna.Framework.Input;
using m_test1_hugo.Class.Main.Menus;

namespace m_test1_hugo.Class.Main.overlay
{
    public class ScoresOverlay : Sprite
    {
        SpriteFont font;
        private const int HEIGHT = 400;
        private const int WIDTH = 600;
        int posX;
        int posY;
        Rectangle sourceRectangle;

        public ScoresOverlay()
        {
            LoadContent(Game1.Content);
            Game1.graphics.IsFullScreen = true;
        }

        public override void LoadContent(ContentManager content)
        {
            texture = content.Load<Texture2D>("players/whiteTransparency");
            font = content.Load<SpriteFont>("font");
            foreach (Team team in Team.TeamList)
            {
                team.TeamPlayerList = new List<Player>();
            }

            posX = Game1.WindowWidth / 2 - WIDTH / 2;
            posY = Game1.WindowHeight / 2 - HEIGHT / 2;
            sourceRectangle = new Rectangle(posX, posY, WIDTH, HEIGHT);
        }
        
        public void Update(GameTime gametime)
        {
            
        }

        public new void Draw(SpriteBatch spriteBatch)
        {
            if (Keyboard.GetState().IsKeyDown(Keys.Tab))
            {
                spriteBatch.Draw(texture, sourceRectangle, Color.Gray);
                int currPosY = posY + 10;
                foreach (Team team in Team.TeamList)
                {
                    foreach (Player player in team.TeamPlayerList)
                    { 
                        string score = player.Kills + " / " + player.Deaths;
                        spriteBatch.DrawString(font, player.Pseudo, new Vector2(posX + 200, currPosY), player.team._Color, 0f, Vector2.Zero, 0.2f, SpriteEffects.None, 1f);
                        spriteBatch.DrawString(font, score, new Vector2(posX + WIDTH - 200, currPosY), player.team._Color, 0f, Vector2.Zero, 0.2f, SpriteEffects.None, 1f);
                        currPosY += 50;
                    }
                    currPosY += 60;
                }
            }
        }
    }
}
﻿using m_test1_hugo.Class.Main.Menus;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework;

namespace m_test1_hugo.Class.gamestates.pages.Editor
{
    class MapEditorPage : MenuPage
    {
        TileSelection tileSelector;

        public MapEditorPage()
        {
           buttons.Add(new SmallButton("ok"));
            buttons[0].Position = new Vector2(400, 0);
           TileSelector = new TileSelection();
        }

        #region prop
        internal TileSelection TileSelector
        {
            get
            {
                return tileSelector;
            }

            set
            {
                tileSelector = value;
            }
        }
        #endregion

        public override MenuPage Action()
        {
            return null;
        }

        public override void Draw(SpriteBatch spriteBatch)
        {
            TileSelector.Draw(spriteBatch);
            foreach (Button button in buttons)
            {
                button.Draw(spriteBatch);
            }
           
        }

        public override void Update()
        {
            // vide
        }
    }
}
﻿using m_test1_hugo.Class.Main.Menus;
using Microsoft.Xna.Framework.Graphics;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.Xna.Framework.Content;

namespace m_test1_hugo.Class.gamestates.pages.Editor
{
    class SmallButton : Button
    {
        public SmallButton(string text) 
            : base(text)
        {
            
        }

        public override void LoadContent(ContentManager content)
        {
            base.LoadContent(content);
            texture = Game1.Content.Load<Texture2D>("menu/smallButton");
        }
    }
}
﻿using m_test1_hugo.Class.Main;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Input;
using m_test1_hugo.Class.Tile_Engine;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;

namespace m_test1_hugo.Class.gamestates.pages.Editor
{
    class TileSelection : Sprite
    {
        #region attributes
        Rectangle sourceRectangle;
        Texture2D bgTex;
        private List<Tile> tileList;
        private bool isActive = false;
        #endregion

        #region construct
        public TileSelection()
        {
            LoadContent(Game1.Content);
        }
        #endregion

        #region properties

        #endregion

        #region methods
        public void Initialize()
        {
            
        }

        public void ScrollDown()
        {

        }

        public void ScrollUp()
        {

        }

        public void Update()
        {
            MouseState mouse = Mouse.GetState();
            if (Bounds.Contains(mouse.Position))
                isActive = true;
            else
                isActive = false;

            if(isActive)
            {
                int previousScroll = mouse.ScrollWheelValue;

                if(mouse.ScrollWheelValue > previousScroll )
                    ScrollUp();
                if(mouse.ScrollWheelValue < previousScroll)
                    ScrollDown();
            }
        }

        public override void LoadContent(ContentManager content)
        {
            this.bgTex = content.Load<Texture2D>("players/green");
            this.sourceRectangle = new Rectangle(0, 0, Game1.WindowWidth / 6, Game1.WindowHeight);
        }

        public new void Draw(SpriteBatch sp)
        {
            sp.Draw(bgTex, sourceRectangle, Color.DarkSlateGray);
        }
        #endregion
    }
}
﻿using m_test1_hugo.Class.Main.Menus;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.Xna.Framework.Graphics;

namespace m_test1_hugo.Class.gamestates.pages
{
    class ExitPage : MenuPage
    {
        public override MenuPage Action()
        {
            return null;
        }

        public override void Draw(SpriteBatch spriteBatch)
        {
            
        }

        public override void Update()
        {

        }
    }
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Content;
using m_test1_hugo.Class.Main.overlay;
using m_test1_hugo.Class.Tile_Engine;
using Microsoft.Xna.Framework.Input;
using m_test1_hugo.Class.ControlLayouts;
using m_test1_hugo.Class.Main.outils_dev_jeu.ControlLayouts;
using m_test1_hugo.Class.Characters.Teams;
using m_test1_hugo.Class.Main.Menus.tools;
using m_test1_hugo.Class.gamestates.pages;

namespace m_test1_hugo.Class.Main.Menus.pages
{
    class MainPage:MenuPage
    {
        private Texture2D bgTexture = Game1.Content.Load<Texture2D>("bg");
        private Vector2 bgPosition = Vector2.Zero;

        public MainPage()
        {
            buttons.Add(new Button("Play !"));
            buttons.Add(new Button("Options"));
            buttons.Add(new Button("Scores"));
            buttons.Add(new Button("Exit"));
        }

        public override void Update()
        {

        }

        public override MenuPage Action()
        {
            if (buttons[0].leftClick())
                return new MultiPage();
            else if (buttons[2].leftClick())
                return new ScorePage();
            else if (buttons[3].leftClick())
                return new ExitPage();
            else
                return null;
        }
        public override void Draw(SpriteBatch spriteBatch)
        {
            spriteBatch.Draw(bgTexture, bgPosition, Color.White);
            var currentY = 50;
            var currentX = Game1.WindowWidth/2-150; // largeur d'un bouton : 300
            foreach (Button button in buttons)
            {
                button.Position = new Vector2(currentX, currentY);
                currentY += 130;
                button.Draw(spriteBatch);
            }
        }
    }
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Content;
using m_test1_hugo.Class.Main.Menus.tools;
using Microsoft.Xna.Framework.Input;
using m_test1_hugo.Class.gamestates.tools;
using m_test1_hugo.Class.Characters.Teams;
using m_test1_hugo.Class.Weapons;
using m_test1_hugo.Class.Network;
using Lidgren.Network;
using m_test1_hugo.Class.gamestates.pages.Editor;
using m_test1_hugo.Class.Characters;
using m_test1_hugo.Class.Characters.Classes;

namespace m_test1_hugo.Class.Main.Menus.pages
{
    class MultiPage:MenuPage
    {
        private bool complete = false;
        private Texture2D bgTexture = Game1.Content.Load<Texture2D>("bg");
        private List<Button> buttonsClass;
        private Vector2 bgPosition = Vector2.Zero;
        KeyboardState kb;
        private TextInput PseudoInput, IpInput;
        private WeaponPicker wpPicker;
        private CharacterClass activeClass;
        //private TeamPicker tPicker;
        private Vector2 wpPickerPosition;

        public MultiPage()
        {
            buttonsClass = new List<Button>();

            buttons.Add(new Button("Create Game"));
            buttons.Add(new Button("Join Game"));
            buttons.Add(new Button("Back"));

            #region classes
            Button c1 = new SmallButton("sprinter");
            c1.Position = new Vector2(Game1.WindowWidth/2-c1.Width-135, 200);
            c1.value = new Sprinter();
            buttonsClass.Add(c1);

            Button c2 = new SmallButton("Tank");
            c2.Position = new Vector2(c1.Position.X + 100, c1.Position.Y);
            c2.value = new Tank();
            buttonsClass.Add(c2);
            #endregion

            PseudoInput = new TextInput("Ton pseudo :", 16);
            PseudoInput.Position = new Vector2(80, Game1.WindowHeight/2-50);
            wpPickerPosition = new Vector2(800, Game1.WindowHeight / 2 - 50);
            wpPicker = new WeaponPicker(wpPickerPosition);
            IpInput = new TextInput("Server IP (join)", 16);
            IpInput.Position = new Vector2(1000, Game1.WindowHeight/ 2 - 50);
            /*tPicker = new TeamPicker(new Vector2(775, Game1.WindowHeight / 2 - 90));
            tPicker.Position = new Vector2(Game1.WindowWidth/2+150, Game1.WindowHeight/2 -50);*/
        }


        public override void Update()
        {

        }

        public override MenuPage Action()
        {
            if(complete)
            {
                if (buttons[0].leftClick())
                {
                    GamePage.server = new Network.Server();
                    GamePage.server.Start();
                    GamePage.client = new Network.Client(Client.GetLocalIPAddress(), 12345);
                    GamePage.client.Start();

                    return new GamePage(Weapon.List[wpPicker.WeaponCount], PseudoInput.Value, wpPicker.ActiveTeam, activeClass);
                }
                else if (buttons[1].leftClick())
                {
                    GamePage.client = new Network.Client(IpInput.Value, 12345);
                    GamePage.client.Start();
                    return new GamePage(Weapon.List[wpPicker.WeaponCount], PseudoInput.Value, wpPicker.ActiveTeam, activeClass);
                }
            }

            if (buttons[2].leftClick())
                return new MainPage();
            
            return null;
        }

        public override void Draw(SpriteBatch spriteBatch)
        {
            spriteBatch.Draw(bgTexture, bgPosition, Color.White);
            kb = Keyboard.GetState();
            var currentY = 50;
            var currentX = 0;

            for (var i = 0; i < Bullet.BulletList.Count; i++)
            {
                Bullet currentBullet = (Bullet)Bullet.BulletList[i];
                currentBullet.Update(Game1.gameTime, 32, Game1.WindowWidth, Game1.WindowHeight);
                currentBullet.Draw(spriteBatch);
            }

            foreach (Button button in buttons)
            {
                if(button.Position == Vector2.Zero)
                {
                    button.Position = new Vector2(currentX, currentY);
                    currentY += 130;
                }
                button.Draw(spriteBatch);
            }

            foreach (Button button in buttonsClass)
            {
                if(button.leftClick() && !button.selected)
                {
                    foreach (Button button2 in buttonsClass)
                        button2.selected = false;

                    button.selected = true;
                    complete = true;
                    activeClass = (CharacterClass)button.value;
                }

                Color color = button.selected ? Color.Red : Color.White;

                spriteBatch.Draw(button.texture, button.Position, color);
                button.DrawText(Game1.spriteBatch);
            }

            PseudoInput.Draw(spriteBatch);
            IpInput.Draw(spriteBatch);
            wpPicker.Update();
        }
    }
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Content;
using m_test1_hugo.Class.Main.overlay;
using m_test1_hugo.Class.Tile_Engine;
using Microsoft.Xna.Framework.Input;
using m_test1_hugo.Class.ControlLayouts;
using m_test1_hugo.Class.Main.outils_dev_jeu.ControlLayouts;
using m_test1_hugo.Class.Characters.Teams;
using m_test1_hugo.Class.Main.Menus.tools;
using System.IO;

namespace m_test1_hugo.Class.Main.Menus.pages
{
    class ScorePage:MenuPage
    {
        private List<string> scores = new List<string>();
        SpriteFont font;
        private static string path = Game1.IsRelease ? "scores/" : "../../../../scores/";

        public ScorePage()
        {
            buttons.Add(new Button("Back"));
            //Console.WriteLine("ScorePage");
            string line;
            
            StreamReader reader;
            if (File.Exists(@path + "scores.txt")) 
            {
                reader = new StreamReader(@path + "scores.txt");
                while ((line = reader.ReadLine()) != null)
                {
                    scores.Add(line);
                }
                font = Game1.Content.Load<SpriteFont>("font");
            }
        }

        public override void Update()
        {

        }

        public override MenuPage Action()
        {
            if (buttons[0].leftClick())
                return new MainPage();
            else
                return null;
        }
        public override void Draw(SpriteBatch spriteBatch)
        {
            var currentY = 50;
            var currentX = Game1.WindowWidth/2-150; // largeur d'un bouton : 300
            foreach (Button button in buttons)
            {
                button.Position = new Vector2(currentX, currentY);
                currentY += 130;
                button.Draw(spriteBatch);
            }

            foreach (string score in scores)
            {
                currentY += 80;
                Vector2 Position = new Vector2(Game1.WindowWidth / 2, currentY);
                spriteBatch.DrawString(font, score, Position, Color.White, 0f, font.MeasureString(score)/2, 0.3f, SpriteEffects.None, 1f );
            }
                
        }
    }
}
﻿using m_test1_hugo.Class.Bonuses;
using m_test1_hugo.Class.Characters;
using m_test1_hugo.Class.Characters.Teams;
using m_test1_hugo.Class.ControlLayouts;
using m_test1_hugo.Class.Main.outils_dev_jeu;
using m_test1_hugo.Class.Main.outils_dev_jeu.ArmesVignette;
using m_test1_hugo.Class.Main.outils_dev_jeu.ControlLayouts;
using m_test1_hugo.Class.Main.outils_dev_jeu.pics;
using m_test1_hugo.Class.Main.overlay;
using m_test1_hugo.Class.Tile_Engine;
using m_test1_hugo.Class.Weapons;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Audio;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.Remoting.Contexts;
using System.Text;
using System.Threading.Tasks;
using Lidgren.Network;
using m_test1_hugo.Class.Network;
using System.Threading;
using m_test1_hugo.Class.Network.Messages;
using m_test1_hugo.Class.Characters.Classes;

namespace m_test1_hugo.Class.Main.Menus.pages
{
    public class GamePage : MenuPage
    {
        #region attributs
        private static string path = Game1.IsRelease ? "scores/scores.txt" : "../../../../scores/scores.txt";
        #region graphics
        Overlay overlay;
        ScoresOverlay scOverlay;
        public static Camera camera;
        SpriteFont font;
        Vector2 BlueScorePosition
        {
            get
            {
                return new Vector2(Game1.WindowWidth / 2 - 50, 150);
            }
        }
        Vector2 RedScorePosition
        {
            get
            {
                return new Vector2(Game1.WindowWidth / 2 + 50, 150);
            }
        }
        #endregion

        #region mouse + keyboard
        public static MouseState ms;
        public static KeyboardState kb;
        public static GamePadState gp;
        public static ControlLayout azerty = new Azerty();
        public static ControlLayout qwerty = new Qwerty();
        public static ControlLayout gamepad = new GamePadController();
        #endregion

        #region map Variables

        TileEngine tileEngine = new TileEngine(32, 32);

        Tileset tileset;

        TileMap map;

        public static int mapWidth;
        public static int mapHeight;
        public static int tilesize = 32;
        #endregion

        #region Players
        private static  Random idrand = new Random(Guid.NewGuid().GetHashCode());
        public static Player player;
        public static List<Player> PlayerList;
        public static List<Player> PlayersToDraw;
        private Texture2D bgtexture;
        private Vector2 bgPosition;
        public static long unique_ID = idrand.Next();
        #endregion

        #region bonuses
        public static List<Bonus> BonusList;
        public static List<Pics> PicList = new List<Pics>();
        #endregion

	#region Network
        public static Server server;
        public static Client client;
	#endregion
	
	#region teleporters
	Teleporter tel1, tel2, tel3, tel4, tel5, tel6, tel7, tel8, tel9, tel10, tel11, tel12, tel13, tel14, tel15, tel16;
	#endregion

        #endregion

        private bool createOK;

        public GamePage(Weapon weapon, string Pseudo, Team team, CharacterClass classe)
        {
            Bullet.BulletList = new List<Bullet>();
            PlayerList = new List<Player>();
            PlayersToDraw = new List<Player>();
            BonusList = new List<Bonus>();
            PicList = new List<Pics>();
            scOverlay = new ScoresOverlay();

            font = Game1.Content.Load<SpriteFont>("font");
            //Console.WriteLine("gamepage created");
            // TODO: Add your initialization logic heres
            #region teams intialization
            #endregion

            #region Récupération seed
            if (server != null)
            {
                server.SvThread = new Thread(server.HandleMessages);
                server.SvThread.Name = "Init server thread";
                server.SvThread.Start();
            }

            client.ClThread = new Thread(client.HandleMessage);
            client.ClThread.Name = "Init client thread";
            client.ClThread.Start();

            while (client.MapSeed == 0)
            {
                NetOutgoingMessage outmsg = client.GameClient.CreateMessage();
                GetMapSeed getmapseed = new GetMapSeed();
                getmapseed.EncodeMessage(outmsg);
                NetSendResult res = client.GameClient.SendMessage(outmsg, NetDeliveryMethod.ReliableOrdered);
                Thread.Sleep(500);
            }

            #endregion

            #region Envoi arrivée

            client.ClThread = new Thread(client.HandleMessage);
            client.ClThread.Name = "Init client thread 2";
            client.ClThread.Start();

            while (!client.IsConnected)
            {
                NetOutgoingMessage outmsg = client.GameClient.CreateMessage();
                SendArrival arrival;
                if (Pseudo == null)
                    arrival = new SendArrival("Jean-Kevin", team._teamNumber, weapon.Name);
                else
                    arrival = new SendArrival(Pseudo, team._teamNumber, weapon.Name);

                arrival.EncodeMessage(outmsg);
                NetSendResult res = client.GameClient.SendMessage(outmsg, NetDeliveryMethod.ReliableOrdered);
                Thread.Sleep(500);
            }

            #endregion

            #region Drawing Map
            Texture2D tilesetTexture = Game1.Content.Load<Texture2D>("terrain");
            tileset = new Tileset(tilesetTexture, 32, 32, 32, 32);

            List<string> maps = new List<string>();
            maps.Add("maps/grassy32/1");
            maps.Add("maps/paved32/1");
            maps.Add("maps/grassy32/1");
            maps.Add("maps/grassy32/1");

            List<string> maps2 = new List<string>();
            maps2.Add("maps/grassy32/2");
            maps2.Add("maps/paved32/2");
            maps2.Add("maps/grassy32/2");
            maps2.Add("maps/grassy32/2");

            List<string> maps3 = new List<string>();
            maps3.Add("maps/special/vide");
            maps3.Add("maps/paved32/3");
            maps3.Add("maps/special/vide");
            maps3.Add("maps/special/vide");

            List<string> ponts = new List<string>();
            ponts.Add("maps/pont/bas-droite");
            ponts.Add("maps/pont/bas-gauche");
            ponts.Add("maps/pont/haut-droite");
            ponts.Add("maps/pont/haut-gauche");

            // Système de génération de séquence aléatoire
            Random random = new Random(client.MapSeed);
            List<int> ordre = new List<int>();
            for (Int32 i = 0; i < maps.Count; i++)
            {
                int val = random.Next(0, maps.Count);
                while (ordre.Contains(val))
                {
                    val = random.Next(0, maps.Count);
                }
                ordre.Add(val);
            }

            List<int> ordreNormal = new List<int>();
            for (int i = 0; i < 4; i++)
            {
                ordreNormal.Add(i);
            }

            MapLayer layer = new MapLayer(maps, 32, ordre);
            MapLayer layer2 = new MapLayer(maps2, 32, ordre);
            MapLayer layer3 = new MapLayer(maps3, 32, ordre);
            MapLayer pont = new MapLayer(ponts, 32, ordreNormal);

            var layers = new List<MapLayer>();
            layers.Add(layer);
            layers.Add(layer2);
            layers.Add(layer3);
            //layers.Add(pont);

            var tilesets = new List<Tileset>();
            tilesets.Add(tileset);

            map = new TileMap(tilesets, layers);
            map.Tilesize = tilesize;
            mapWidth = map.GetWidth();
            mapHeight = map.GetHeight();
            #endregion
            createOK = true;
           
            player = new Player(Pseudo, classe, weapon, team, azerty, Spawn.RandomVector(map));
            player.weapon.CurrentAmmo = player.weapon.MagazineSize;
            PlayerList.Add(player);
            PlayersToDraw.Add(player);
            player.Id = unique_ID;
            if (player.weapon is Glock)
                player.weapon = new Glock(player);

            if (player.weapon is Fal)
                player.weapon = new Fal(player);

            if (player.weapon is Sniper)
                player.weapon = new Sniper(player);
            
            Heal heal = new Heal();
            heal.Position = Spawn.RandomVector(map);


            new MagicBox(Spawn.RandomVector(map));

            overlay = new Overlay(player);

            camera = new Camera(Game1.graphics.GraphicsDevice.Viewport);

            //new Player(new Sprinter(), new Assault(), Team.TeamList[1], gamepad, Spawn.RandomVector(800,800));
            bgtexture = Game1.Content.Load<Texture2D>("bg");
            
			
			tel1 = new Teleporter(new Vector2(955, 200), Teleporter.Side.Right);
			tel2 = new Teleporter(new Vector2(1040, 200), Teleporter.Side.Left);
			tel3 = new Teleporter(new Vector2(955, 750), Teleporter.Side.Right);
			tel4 = new Teleporter(new Vector2(1040, 750), Teleporter.Side.Left);
			tel5 = new Teleporter(new Vector2(200, 955), Teleporter.Side.Up);
			tel6 = new Teleporter(new Vector2(200, 1040), Teleporter.Side.Down);
			tel7 = new Teleporter(new Vector2(750, 955), Teleporter.Side.Up);
			tel8 = new Teleporter(new Vector2(750, 1040), Teleporter.Side.Down);
			tel9 = new Teleporter(new Vector2(1240, 955), Teleporter.Side.Up);
			tel10 = new Teleporter(new Vector2(1240, 1040), Teleporter.Side.Down);
			tel11 = new Teleporter(new Vector2(1790, 955), Teleporter.Side.Up);
			tel12 = new Teleporter(new Vector2(1790, 1040), Teleporter.Side.Down);
			tel13 = new Teleporter(new Vector2(955, 1240), Teleporter.Side.Right);
			tel14 = new Teleporter(new Vector2(1040, 1240), Teleporter.Side.Left);
			tel15 = new Teleporter(new Vector2(955, 1790), Teleporter.Side.Right);
			tel16 = new Teleporter(new Vector2(1040, 1790), Teleporter.Side.Left);
			tel1.setLink(tel2);
			tel3.setLink(tel4);
			tel5.setLink(tel6);
			tel7.setLink(tel8);
			tel9.setLink(tel10);
			tel11.setLink(tel12);
			tel13.setLink(tel14);
			tel15.setLink(tel16);
        }

        public override MenuPage Action()
        {
	    #region Network

            if (server != null)
            {
                if (server.SvThread == null)
                {
                    server.SvThread = new Thread(server.HandleMessages);
                    server.SvThread.Name = "Server thread";
                    server.SvThread.Start();
                }
            }

            if (client.ClThread == null)
            {
                client.ClThread = new Thread(client.HandleMessage);
                client.ClThread.Name = "Client thread";
                client.ClThread.Start();
            }

            if (client.RecievedPlayerData != null)
            {
                if (PlayerList.Count > 1)
                {
                    Player p = PlayerList.Find(x => x.Id == client.RecievedPlayerData.ID);
                    if (p != null)
                        client.RecievedPlayerData.TransferDataToPlayer(p);
                }
            }

            #endregion
            Update();
            foreach(Team team in Team.TeamList)
            {
                if (team.TeamKills >= 10)
                {
                    SaveResults();
                    return new MainPage();
                }
                else
                {
                    return null;
                }
            }
            return null;
        }

        public override void Draw(SpriteBatch spriteBatch)
        {
            spriteBatch.End();
            var viewMatrix = camera.GetViewMatrix();
            
            spriteBatch.Begin(transformMatrix: viewMatrix);

            bgPosition = camera.Origin;
            //spriteBatch.Draw(bgtexture, bgPosition, Color.White);

            map.Draw(spriteBatch);
            
            #region Drawing and updating Bonuses
            for (var i = 0; i < BonusList.Count; i++)
            {
                var currentBonus = BonusList[i];
                currentBonus.Draw(spriteBatch);
                currentBonus.Update(Game1.gameTime);
                currentBonus.UpdateSprite(Game1.gameTime);
            }
            #endregion

            #region Drawing and updating bullets
            for (var i = 0; i < Bullet.BulletList.Count; i++)
            {
                Bullet currentBullet = (Bullet)Bullet.BulletList[i];
                currentBullet.Update(Game1.gameTime, 32, mapWidth, mapHeight, map.BCollisionLayer);
                currentBullet.Draw(spriteBatch);
            }
            #endregion

            #region Drawing and updating players
            Player bad_player = PlayerList.Find(x => x.Id == 0);
            if (bad_player != null)
                PlayerList.Remove(bad_player);
            for (var i = 0; i < PlayersToDraw.Count; i++)
            {
                Player player = PlayersToDraw[i];
                player.Control(Game1.gameTime, 32, mapWidth, mapHeight, map.PCollisionLayer);
            }

            for (var i = 0; i < PlayersToDraw.Count; i++)
            {
                Player player = PlayersToDraw[i];
                player.healthBar.Draw(spriteBatch);
                player.DrawCharacter(Game1.spriteBatch);
            }

            #endregion

            #region Drawing WeaponPics
            for (var i = 0; i < GamePage.PicList.Count; i++)
            {
                if (GamePage.PicList[i] is WeaponPic)
                {
                    WeaponPic weaponPic = (WeaponPic)GamePage.PicList[i];
                    weaponPic.Draw(spriteBatch);
                }
                else if (GamePage.PicList[i] is ClothPic)
                {
                    ClothPic clothPic = (ClothPic)GamePage.PicList[i];
                    clothPic.Draw(spriteBatch);
                }

            }
            #endregion
            spriteBatch.End(); // fin spritebatch

            spriteBatch.Begin(); // tout ce qui ne bouge pas avec la camera

            overlay.Draw(spriteBatch);
            #region drawing clothes to body

            for (var i = 0; i < player.ClothesList.Length; i++)
            {
                if (player.ClothesList[i] != null)
                {
                    player.ClothesList[i].Draw(spriteBatch);
                }

            }
            DrawTeamScores(spriteBatch);
            scOverlay.Draw(spriteBatch);
            #endregion
        }

        public override void Update()
        {
            //overlay.Update(Game1.gameTime);
            ms = Mouse.GetState();
            kb = Keyboard.GetState();

            foreach (Team team in Team.TeamList)
                team.Update();

            if (player.IsDead())
            {
                if (kb.IsKeyDown(Keys.NumPad1))
                {
                    player.Respawn(Spawn.RandomVector(map), PlayersToDraw);
                    client.SendRespawn(player.Id);
                }
            }
            /*
            if (kb.IsKeyDown(Keys.P))
            {
                new ClothBox(Spawn.RandomVector(map));
                //player.weapon = new shotgun(player);
            }

            if (kb.IsKeyDown(Keys.I))
            {
                new MagicBox(Spawn.RandomVector(map));
                //player.weapon = new shotgun(player);
            }

            if (kb.IsKeyDown(Keys.O))
            {
                if (createOK)
                {
                    new Player(new Sprinter(), new Assault(), Team.TeamList[1], gamepad, Spawn.RandomVector(map));
                    new Player(new Sprinter(), new Assault(), Team.TeamList[0], gamepad, Spawn.RandomVector(map));
                    createOK = false;
                }
                    
            }
            if (kb.IsKeyUp(Keys.O))
                createOK = true;
            */
        }

        public void DrawTeamScores(SpriteBatch spriteBatch)
        {
            string blueScore = Team.TeamList[0].TeamKills.ToString();
            string redScore = Team.TeamList[1].TeamKills.ToString();
            spriteBatch.DrawString(font, blueScore, BlueScorePosition, Team.TeamList[0]._Color, 0f, font.MeasureString(blueScore), 0.6f, SpriteEffects.None, 0.3f ); //drawing blue score
            spriteBatch.DrawString(font, ":", new Vector2(BlueScorePosition.X + 30, 100), Color.White, 0f, font.MeasureString(":") / 2, 0.6f, SpriteEffects.None, 0.3f); 
            spriteBatch.DrawString(font, redScore, RedScorePosition, Team.TeamList[1]._Color, 0f, font.MeasureString(redScore), 0.6f, SpriteEffects.None, 0.3f); //drawing red score
        }

        private void SaveResults()
        {
            var player = GamePage.player;
            string text = "joueur : " + player.Pseudo + "      Score : " + player.Kills + "/" + player.Deaths +"      Heure :"+ DateTime.Now.Hour + ":" +DateTime.Now.Minute;
            StreamWriter swFile = new StreamWriter(@path, true);
            swFile.WriteLine(text);
            swFile.Close();
        }
    }
}
﻿using m_test1_hugo.Class.Main.interfaces;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Input;

namespace m_test1_hugo.Class.Main.Menus
{
    public class Button : Sprite, Clickable
    {
        public bool clicked, rightClicked;
        public bool selected;

        private string text;
        public Object value;
        public string Text
        {
            get { return text; }
        }

        public SpriteFont font;
        private Vector2 textPosition;

        public Button(string text)
        {
            this.text = text;
            LoadContent(Game1.Content);
        }

        public override void LoadContent(ContentManager content)
        {
            texture = content.Load<Texture2D>("menu/button");
            font = content.Load<SpriteFont>("font");
        }

        public bool leftClick()
        {
            if (Bounds.Contains(Mouse.GetState().Position.X, Mouse.GetState().Position.Y) && Mouse.GetState().LeftButton == ButtonState.Pressed && !clicked)
            {
                clicked = true;
                return false;
            }
            else if (clicked && Bounds.Contains(Mouse.GetState().Position.X, Mouse.GetState().Position.Y))
            {
                if (Mouse.GetState().LeftButton == ButtonState.Released)
                    return true;
            }
            else
            {
                clicked = false;
            }
            return false;
        }

        public bool rightClick()
        {
            if (Bounds.Contains(Mouse.GetState().Position.X, Mouse.GetState().Position.Y) && Mouse.GetState().RightButton == ButtonState.Pressed)
            {
                rightClicked = true;
                return false;
            }
            else if (rightClicked && Bounds.Contains(Mouse.GetState().Position.X, Mouse.GetState().Position.Y))
            {
                if (Mouse.GetState().RightButton == ButtonState.Released)
                    return true;
            }
            else
            {
                rightClicked = false;
            }
            return false;
        }

        public new void Draw (SpriteBatch spriteBatch)
        {
            LoadContent(Game1.Content);
            spriteBatch.Draw(texture, Position, Color.White);
            textPosition = this.Center;
            DrawText(spriteBatch);
        }

        public void DrawText(SpriteBatch spriteBatch)
        {
            spriteBatch.DrawString(font, text, Center, Color.GhostWhite, 0f, new Vector2(font.MeasureString(text).X / 2, font.MeasureString(text).Y / 2), 0.23f, SpriteEffects.None, 1f);
        }

    }
}
﻿/*using m_test1_hugo.Class.Main;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using m_test1_hugo.Class.Characters.Teams;
using Microsoft.Xna.Framework.Input;
using m_test1_hugo.Class.Characters;
using m_test1_hugo.Class.ControlLayouts;
using m_test1_hugo.Class.Main.outils_dev_jeu.ControlLayouts;
using m_test1_hugo.Class.Main.Menus.pages;
using m_test1_hugo.Class.Weapons;

namespace m_test1_hugo.Class.gamestates.tools
{
    class TeamPicker : Sprite
    {
        private bool hold;
        private Color activeColor;
        
        private SpriteFont font;
        private int count;
        public Team activeTeam;
        //Texture2D UpArrow, DownArrow;
        

        #region properties
        public Color ActiveColor
        {
            get
            {
                return activeColor;
            }

            set
            {
                activeColor = value;
            }
        }

        public SpriteFont Font
        {
            get
            {
                return font;
            }

            set
            {
                font = value;
            }
        }

        public bool Hold
        {
            get
            {
                return hold;
            }

            set
            {
                hold = value;
            }
        }

        public int Count
        {
            get
            {
                return count;
            }

            set
            {
                count = value;
            }
        }

      

        #endregion

        public TeamPicker(Vector2 Position)
        {
            
            this.Position = Position;
            LoadContent(Game1.Content);
        }

        public override void LoadContent(ContentManager content)
        {
            
          
            Font = content.Load<SpriteFont>("font");
            TextPosition = new Vector2(Center.X, Position.Y + 50);
            TeamNamePosition  = new Vector2(Center.X, Center.Y + 50);
            
        }

        public void Update()
        {
            
        }

        public  new void Draw(SpriteBatch spriteBatch)
        {
            //(float)Math.Tan(act - Mouse.GetState().Position.Y/Mouse.GetState().Position.X);
            Console.WriteLine(ActivePlayer.MouseRotationAngle);
            
            
            
            //spriteBatch.DrawString(Font, activeTeam._name, TeamNamePosition, ActiveColor);
        }
    }
}
*/﻿using m_test1_hugo.Class.Main;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework;
using m_test1_hugo.Class.Main.outils_dev_jeu.ArmesVignette;
using Microsoft.Xna.Framework.Input;
using m_test1_hugo.Class.Characters.Teams;
using m_test1_hugo.Class.Characters;
using m_test1_hugo.Class.Main.outils_dev_jeu.ControlLayouts;
using m_test1_hugo.Class.Weapons;
using m_test1_hugo.Class.ControlLayouts;

namespace m_test1_hugo.Class.gamestates.tools
{
    class WeaponPicker : Sprite
    {
        private List<Player> Players = new List<Player>();
        private Weapon[] WeaponList = Weapon.List;
        private WeaponPic ActivePic;
        public int TeamCount = 0, WeaponCount = 0;
        private SpriteFont font;
        public Vector2 PicPosition, RightArrowPos, LeftArrowPos, WeaponTextPosition;
        public bool wHold, tHold; // weaponHold, TeamHold
        private Color ActiveColor;
        private Player ActivePlayer;
        public Team ActiveTeam;
        public static float CO;

        Texture2D LeftArrow, RightArrow, UpArrow, DownArrow;
        
        #region properties

        public Vector2 UpArrowPos
        {
            get
            {
                return new Vector2(Position.X, Position.Y - 250);
            }
        }

        public Vector2 DownArrowPos
        {
            get
            {
                return new Vector2(Position.X, Position.Y + 250);
            }
        }
        #endregion

        public WeaponPicker(Vector2 pos)
        {
            Position = pos;
            LoadContent(Game1.Content);
        }

        public override void LoadContent(ContentManager content)
        {
            #region teams
            Team TeamBlue = new Team(1, "blue", Color.Blue);
            Team TeamRed = new Team(2, "red", Color.Red);
            #endregion
            font = content.Load<SpriteFont>("font");
            texture = content.Load<Texture2D>("menu/textarea");
            #region arrows
            UpArrow = content.Load<Texture2D>("menu/UpArrow");
            DownArrow = content.Load<Texture2D>("menu/DownArrow");
            LeftArrow = content.Load<Texture2D>("menu/LeftArrow");
            RightArrow = content.Load<Texture2D>("menu/RightArrow");
            #endregion
            ActivePic = new WeaponPic(WeaponList[0], Center);
            PicPosition = new Vector2(Position.X, 50/2);
            RightArrowPos = new Vector2(Position.X+150, Position.Y);
            LeftArrowPos = new Vector2(PicPosition.X - 150, RightArrowPos.Y);
            WeaponTextPosition = new Vector2(PicPosition.X+20, Center.Y-80);

            #region players
            Players.Add(new Player(new Sprinter(), null, TeamBlue, new Azerty(), Position));
            Players.Add(new Player(new Sprinter(), null, TeamRed, new Azerty(), Position));
            Players[0].Pseudo = "";
            Players[1].Pseudo = "";
            Players[0].LoadContent(content);
            Players[1].LoadContent(content);
            #endregion
            ActiveColor = Color.Blue;
            ActivePlayer = Players[0];
        }

        public new void Draw(SpriteBatch spriteBatch)
        {
            spriteBatch.DrawString(font, WeaponList[WeaponCount].Name, WeaponTextPosition, Color.White, 0f, font.MeasureString(WeaponList[WeaponCount].Name)/2, 0.3f, SpriteEffects.None, 1f);

            if (WeaponCount < WeaponList.Count() - 1)
                spriteBatch.Draw(RightArrow, RightArrowPos, Color.White);

            if(WeaponCount > 0)
                spriteBatch.Draw(LeftArrow, LeftArrowPos, Color.White);

            spriteBatch.Draw(UpArrow, UpArrowPos, ActiveColor);
            spriteBatch.Draw(DownArrow, DownArrowPos, ActiveColor);
            ActivePlayer.isMoving = true;
            ActivePlayer.Draw(spriteBatch);


            var CursY = Mouse.GetState().Position.Y;
            var CursX = Mouse.GetState().Position.X;
            var CA = -(ActivePlayer.Center.Y - CursY);
            CO = -(ActivePlayer.Center.X - CursX);
            var MouseRotationAngle = (float)(Math.Atan(CA / CO));
            ActivePlayer.MouseRotationAngle = MouseRotationAngle;

            if (ActivePlayer.weapon != null)
            {
                if (CO <= 0)// cote oppose holder ( voir dans les attributs, et faire un schema si besoin)
                {
                    spriteBatch.Draw(ActivePic.texture, ActivePlayer.Center, null, Color.White, MouseRotationAngle, new Vector2(0, ActivePlayer.weapon.Height / 2), -1.0f, SpriteEffects.FlipVertically, 0f); // mettre en comm pour tester ce que ca fait 
                }
                else
                {
                    spriteBatch.Draw(ActivePic.texture, ActivePlayer.Center, null, Color.White, MouseRotationAngle, new Vector2(0, ActivePlayer.weapon.Height / 2), 1.0f, SpriteEffects.None, 0f);
                }
            }
        }

        public void Update()
        {
            Draw(Game1.spriteBatch);
            KeyboardState kb = Keyboard.GetState();
            if (kb.IsKeyDown(Keys.Right) && WeaponCount < WeaponList.Count()-1 && !wHold)
            {
                wHold = true;
                WeaponCount++;
                ActivePic = new WeaponPic(WeaponList[WeaponCount], Center);
                ActivePlayer.weapon = WeaponList[WeaponCount];
                //draw la fleche
            }

            else if (kb.IsKeyDown(Keys.Left) && WeaponCount > 0 && !wHold)
            {
                wHold = true;
                WeaponCount--;
                ActivePic = new WeaponPic(WeaponList[WeaponCount], Center);
                ActivePlayer.weapon = WeaponList[WeaponCount];
                //draw la fleche
            }
            if (kb.IsKeyUp(Keys.Left) && kb.IsKeyUp(Keys.Right))
                wHold = false;
            #region teamPicker
            if (kb.IsKeyDown(Keys.Up) && !tHold)
            {
                tHold = true;
                TeamCount++;
            }
            else if (kb.IsKeyDown(Keys.Down) && !tHold)
            {
                tHold = true;
                TeamCount--;
            }
            else if (kb.IsKeyUp(Keys.Down) && kb.IsKeyUp(Keys.Up))
            {
                tHold = false;
            }
            int index = TeamCount % 2 == 0 ? 0 : 1;
            ActiveColor = TeamCount % 2 == 0 ? Color.Blue : Color.Red;
            ActivePlayer = TeamCount % 2 == 0 ? Players[0] : Players[1];
            ActiveTeam = Team.TeamList[index];
            ActivePlayer.weapon = WeaponList[WeaponCount];
            ActivePlayer.weapon.Holder = ActivePlayer;
            /*if (ActivePlayer.weapon != null)
                ActivePlayer.;*/
            ActivePlayer.UpdateSprite(Game1.gameTime);
            ActivePlayer.Control(Game1.gameTime);

            Draw(Game1.spriteBatch);
            #endregion
        }
    }
}﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Input;
using System.Text.RegularExpressions;

namespace m_test1_hugo.Class.Main.Menus.tools
{
    public class TextInput:Button
    {
        #region attributs
        private bool released;
        private Keys lastKeyPressed;
        private SpriteFont font;
        private bool focus;
        private Color color;
        private int length;
        private string value;

        #endregion

        #region prop
        public int Length
        {
            get
            {
                return length;
            }

            private set
            {
                length = value;
            }
        }

        private Vector2 TextPosition
        {
            get
            {
                return new Vector2(Position.X + 40, Position.Y + 210);
            }
        }
        private Vector2 LabelPosition
        {
            get
            {
                return new Vector2(Position.X + 30, Position.Y + 30);
            }
        }

        private string label;
        public string Label
        {
            get
            {
                return label;
            }

            private set
            {
                label = value;
            }
        }



        //private string text;
        /*public string Text
        {
            get
            {
                return text;
            }

            private set
            {
                text = value;
            }
        }*/

        public bool Focus
        {
            get
            {
                return focus;
            }

            set
            {
                focus = value;
            }
        }

        public Color Color
        {
            get
            {
                return color;
            }

            set
            {
                color = value;
            }
        }

        public string Value
        {
            get
            {
                return value;
            }

            set
            {
                this.value = value;
            }
        }
        #endregion

        #region construct
        public TextInput(string label, int length)
            :base(label)
        {
            Label = label;
            Value = "";
            Length = length;
            released = true;
        }
        #endregion

        #region methodes
        public void Update()
        {
            #region focus
            if (leftClick())
            {
                Focus = true;
            }
            if (Focus && Mouse.GetState().LeftButton == ButtonState.Pressed && !this.Bounds.Contains(Mouse.GetState().Position))
                Focus = false;
            #region color
            if (Focus)
                color = Color.Firebrick;
            else
                color = Color.White;
            #endregion
            #endregion
            #region input
            if (Focus)
            {
                KeyboardState kb = Keyboard.GetState();
                if (kb.GetPressedKeys().Length > 0 && Value.Length < Length) // si une touche est pressed et la taille de la string est < 16
                {
                    var lastIndex = kb.GetPressedKeys().Length - 1; // on recupere l'index de la derniere touche appuyee
                    var key = kb.GetPressedKeys()[lastIndex]; // on recupere la derniere touche appuyee
                    if (key != Keys.Back && (key != lastKeyPressed || released)) // si on appuie sur une autre toushe que backspace
                    {
                        string s = key.ToString().ToLower();

                        if (s.Substring(0, s.Length - 1) == "numpad")
                        {
                            s = s.Substring(s.Length - 1, 1);
                        }
                        else if (s == "decimal")
                            s = ".";
                        //Console.WriteLine(s);
                        Regex r = new Regex("^[a-zA-Z0-9\\.]{1}$");  // expression reguliere pour tester si alphanumerique
                        if (r.IsMatch(s)) // si la touche appuyee est alphanum
                        {
                            value += s; // on ajoute la lettre associee a la touche
                            released = false;
                        }
                        lastKeyPressed = key;
                    }
                }
                else
                    released = true;
                if (released && kb.IsKeyDown(Keys.Back)) // si on appuie sur backspace
                {
                    if (value.Length >= 1) // si on a quelquechose a effacer
                        value = value.Substring(0, value.Length - 1); // on efface
                    released = false;
                }
            }
            #endregion
        }

        public override void LoadContent(ContentManager content)
        {
            font = content.Load<SpriteFont>("font");
            texture = content.Load<Texture2D>("menu/textarea");
            color = Color.White;
        }

        public new void Draw(SpriteBatch spriteBatch)
        {
            LoadContent(Game1.Content);
            Update();
            spriteBatch.Draw(texture, Position, color);
            spriteBatch.DrawString(font, Label, LabelPosition, Color.White, 0f, Vector2.Zero, 0.35f, SpriteEffects.None, 1f);
            spriteBatch.DrawString(font, value, TextPosition, Color.White, 0f, Vector2.Zero, 0.25f, SpriteEffects.None, 1f);
        }
        #endregion
    }
}
﻿using m_test1_hugo.Class.Main.Menus.pages;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace m_test1_hugo.Class.Main.Menus
{
    public class GameState
    {
        public MenuPage activePage;

        public GameState()
        {
            //Console.WriteLine("gameState Created");
            activePage = new MainPage();
        }

        public void Draw(SpriteBatch spriteBatch)//okk juste draw les boutons
        {
            activePage.Update();
            activePage.Draw(spriteBatch);

            var action = activePage.Action();
            if (action != null)
            {
                activePage = action;
            }
        }
    }
}
